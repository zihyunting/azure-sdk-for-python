# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import _model_base, models as _models
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Serializer
from .._vendor import FaceClientMixinABC, prepare_multipart_form_data

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_face_lists_create_list_request(face_list_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/facelists/{faceListId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_face_lists_delete_list_request(face_list_id: str, **kwargs: Any) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/facelists/{faceListId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_face_lists_get_list_request(
    face_list_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/facelists/{faceListId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_lists_update_list_request(face_list_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/facelists/{faceListId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_face_lists_add_face_from_url_request(  # pylint: disable=name-too-long
    face_list_id: str,
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/facelists/{faceListId}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_lists_add_face_from_stream_request(  # pylint: disable=name-too-long
    face_list_id: str,
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/facelists/{faceListId}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_lists_delete_face_request(face_list_id: str, persisted_face_id: str, **kwargs: Any) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/facelists/{faceListId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_face_lists_list_list_request(
    *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/facelists"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_lists_find_similar_from_face_list_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/findsimilars"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_create_list_request(  # pylint: disable=name-too-long
    large_face_list_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_delete_list_request(  # pylint: disable=name-too-long
    large_face_list_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_large_face_lists_get_list_request(
    large_face_list_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_face_lists_update_list_request(  # pylint: disable=name-too-long
    large_face_list_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_add_face_from_url_request(  # pylint: disable=name-too-long
    large_face_list_id: str,
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_face_lists_add_face_from_stream_request(  # pylint: disable=name-too-long
    large_face_list_id: str,
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_face_lists_delete_face_request(  # pylint: disable=name-too-long
    large_face_list_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_large_face_lists_list_list_request(
    *,
    start: Optional[str] = None,
    top: Optional[int] = None,
    return_recognition_model: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largefacelists"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_face_lists_train_list_request(  # pylint: disable=name-too-long
    large_face_list_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}/train"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="POST", url=_url, **kwargs)


def build_large_face_lists_get_training_status_request(  # pylint: disable=name-too-long
    large_face_list_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}/training"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_get_face_request(
    large_face_list_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_update_face_request(  # pylint: disable=name-too-long
    large_face_list_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_list_face_request(
    large_face_list_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largefacelists/{largeFaceListId}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_face_lists_find_similar_from_large_face_list_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/findsimilars"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_async_operations_get_status_request(  # pylint: disable=name-too-long
    operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/operations/{operationId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_directory_persons_create_person_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persons"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_person_directory_persons_delete_person_request(  # pylint: disable=name-too-long
    person_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_person_directory_persons_get_person_request(  # pylint: disable=name-too-long
    person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_directory_persons_update_person_request(  # pylint: disable=name-too-long
    person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_person_directory_persons_list_person_request(  # pylint: disable=name-too-long
    *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persons"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directory_persons_list_group_reference_request(  # pylint: disable=name-too-long
    person_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}/dynamicPersonGroupReferences"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directory_persons_add_face_from_url_request(  # pylint: disable=name-too-long
    person_id: str,
    recognition_model: Union[str, _models.RecognitionModel],
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "recognitionModel": _SERIALIZER.url("recognition_model", recognition_model, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directory_persons_add_face_from_stream_request(  # pylint: disable=name-too-long
    person_id: str,
    recognition_model: Union[str, _models.RecognitionModel],
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "recognitionModel": _SERIALIZER.url("recognition_model", recognition_model, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directory_persons_delete_face_request(  # pylint: disable=name-too-long
    person_id: str, recognition_model: Union[str, _models.RecognitionModel], persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "recognitionModel": _SERIALIZER.url("recognition_model", recognition_model, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_person_directory_persons_get_face_request(  # pylint: disable=name-too-long
    person_id: str, recognition_model: Union[str, _models.RecognitionModel], persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "recognitionModel": _SERIALIZER.url("recognition_model", recognition_model, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_directory_persons_update_face_request(  # pylint: disable=name-too-long
    person_id: str, recognition_model: Union[str, _models.RecognitionModel], persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "recognitionModel": _SERIALIZER.url("recognition_model", recognition_model, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_person_directory_persons_list_face_request(  # pylint: disable=name-too-long
    person_id: str, recognition_model: Union[str, _models.RecognitionModel], **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persons/{personId}/recognitionModels/{recognitionModel}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "recognitionModel": _SERIALIZER.url("recognition_model", recognition_model, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_directory_persons_identify_from_person_directory_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/identify"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_person_directory_persons_verify_from_person_directory_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/verify"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_person_directory_dynamic_person_groups_create_group_request(  # pylint: disable=name-too-long
    dynamic_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/dynamicpersongroups/{dynamicPersonGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "dynamicPersonGroupId": _SERIALIZER.url("dynamic_person_group_id", dynamic_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_person_directory_dynamic_person_groups_delete_group_request(  # pylint: disable=name-too-long
    dynamic_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/dynamicpersongroups/{dynamicPersonGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "dynamicPersonGroupId": _SERIALIZER.url("dynamic_person_group_id", dynamic_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_person_directory_dynamic_person_groups_get_group_request(  # pylint: disable=name-too-long
    dynamic_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/dynamicpersongroups/{dynamicPersonGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "dynamicPersonGroupId": _SERIALIZER.url("dynamic_person_group_id", dynamic_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_directory_dynamic_person_groups_update_group_request(  # pylint: disable=name-too-long
    dynamic_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/dynamicpersongroups/{dynamicPersonGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "dynamicPersonGroupId": _SERIALIZER.url("dynamic_person_group_id", dynamic_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_person_directory_dynamic_person_groups_list_group_request(  # pylint: disable=name-too-long
    *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/dynamicpersongroups"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directory_dynamic_person_groups_list_group_person_request(  # pylint: disable=name-too-long
    dynamic_person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/dynamicpersongroups/{dynamicPersonGroupId}/persons"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "dynamicPersonGroupId": _SERIALIZER.url("dynamic_person_group_id", dynamic_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_directory_dynamic_person_groups_identify_from_dynamic_person_group_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/identify"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_person_groups_create_group_request(person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_person_groups_delete_group_request(person_group_id: str, **kwargs: Any) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_person_groups_get_group_request(
    person_group_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_update_group_request(person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_person_groups_list_group_request(
    *,
    start: Optional[str] = None,
    top: Optional[int] = None,
    return_recognition_model: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persongroups"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_create_person_request(  # pylint: disable=name-too-long
    person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_person_groups_delete_person_request(  # pylint: disable=name-too-long
    person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons/{personId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_person_groups_get_person_request(person_group_id: str, person_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons/{personId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_groups_update_person_request(  # pylint: disable=name-too-long
    person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons/{personId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_person_groups_list_person_request(
    person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_add_face_from_url_request(  # pylint: disable=name-too-long
    person_group_id: str,
    person_id: str,
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons/{personId}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_add_face_from_stream_request(  # pylint: disable=name-too-long
    person_group_id: str,
    person_id: str,
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons/{personId}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_delete_face_request(
    person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_person_groups_get_face_request(
    person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_groups_update_face_request(
    person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_person_groups_identify_from_person_group_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/identify"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_person_groups_verify_from_person_group_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/verify"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_person_groups_train_group_request(person_group_id: str, **kwargs: Any) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/train"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="POST", url=_url, **kwargs)


def build_person_groups_get_training_status_request(  # pylint: disable=name-too-long
    person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/persongroups/{personGroupId}/training"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_create_group_request(  # pylint: disable=name-too-long
    large_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_delete_group_request(  # pylint: disable=name-too-long
    large_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_large_person_groups_get_group_request(  # pylint: disable=name-too-long
    large_person_group_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_update_group_request(  # pylint: disable=name-too-long
    large_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_list_group_request(  # pylint: disable=name-too-long
    *,
    start: Optional[str] = None,
    top: Optional[int] = None,
    return_recognition_model: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_create_person_request(  # pylint: disable=name-too-long
    large_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_delete_person_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons/{personId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_large_person_groups_get_person_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons/{personId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_update_person_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons/{personId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_list_person_request(  # pylint: disable=name-too-long
    large_person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_add_face_from_url_request(  # pylint: disable=name-too-long
    large_person_group_id: str,
    person_id: str,
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_add_face_from_stream_request(  # pylint: disable=name-too-long
    large_person_group_id: str,
    person_id: str,
    *,
    target_face: Optional[str] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "str")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_delete_face_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = (
        "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    )
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_large_person_groups_get_face_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    )
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_update_face_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = (
        "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    )
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_identify_from_large_person_group_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/identify"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_verify_from_large_person_group_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/verify"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_train_group_request(  # pylint: disable=name-too-long
    large_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/train"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="POST", url=_url, **kwargs)


def build_large_person_groups_get_training_status_request(  # pylint: disable=name-too-long
    large_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/largepersongroups/{largePersonGroupId}/training"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_liveness_sessions_list_sessions_request(  # pylint: disable=name-too-long
    *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detectLiveness/singleModal/sessions"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_liveness_sessions_get_session_request(  # pylint: disable=name-too-long
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detectLiveness/singleModal/sessions/{sessionId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_liveness_sessions_delete_session_request(  # pylint: disable=name-too-long
    session_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/detectLiveness/singleModal/sessions/{sessionId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_liveness_sessions_list_session_audit_entries_request(  # pylint: disable=name-too-long
    session_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detectLiveness/singleModal/sessions/{sessionId}/audit"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_liveness_sessions_create_session_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detectLiveness/singleModal/sessions"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_liveness_with_verify_sessions_list_sessions_request(  # pylint: disable=name-too-long
    *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detectLivenessWithVerify/singleModal/sessions"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_liveness_with_verify_sessions_get_session_request(  # pylint: disable=name-too-long
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detectLivenessWithVerify/singleModal/sessions/{sessionId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_liveness_with_verify_sessions_delete_session_request(  # pylint: disable=name-too-long
    session_id: str, **kwargs: Any
) -> HttpRequest:
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    # Construct URL
    _url = "/face/{apiVersion}/detectLivenessWithVerify/singleModal/sessions/{sessionId}"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    return HttpRequest(method="DELETE", url=_url, **kwargs)


def build_liveness_with_verify_sessions_list_session_audit_entries_request(  # pylint: disable=name-too-long
    session_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detectLivenessWithVerify/singleModal/sessions/{sessionId}/audit"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_liveness_with_verify_sessions_create_session_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detectLivenessWithVerify/singleModal/sessions"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_liveness_with_verify_sessions_create_session_with_verify_image_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detectLivenessWithVerify/singleModal/sessions"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_detect_from_url_request(
    *,
    return_face_id: Optional[bool] = None,
    return_face_landmarks: Optional[bool] = None,
    return_face_attributes: Optional[str] = None,
    recognition_model: Optional[Union[str, _models.RecognitionModel]] = None,
    return_recognition_model: Optional[bool] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    face_id_time_to_live: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detect"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_face_id is not None:
        _params["returnFaceId"] = _SERIALIZER.query("return_face_id", return_face_id, "bool")
    if return_face_landmarks is not None:
        _params["returnFaceLandmarks"] = _SERIALIZER.query("return_face_landmarks", return_face_landmarks, "bool")
    if return_face_attributes is not None:
        _params["returnFaceAttributes"] = _SERIALIZER.query("return_face_attributes", return_face_attributes, "str")
    if recognition_model is not None:
        _params["recognitionModel"] = _SERIALIZER.query("recognition_model", recognition_model, "str")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if face_id_time_to_live is not None:
        _params["faceIdTimeToLive"] = _SERIALIZER.query("face_id_time_to_live", face_id_time_to_live, "int")

    # Construct headers
    if content_type is not None:
        _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_detect_from_stream_request(
    *,
    return_face_id: Optional[bool] = None,
    return_face_landmarks: Optional[bool] = None,
    return_face_attributes: Optional[str] = None,
    recognition_model: Optional[Union[str, _models.RecognitionModel]] = None,
    return_recognition_model: Optional[bool] = None,
    detection_model: Optional[Union[str, _models.DetectionModel]] = None,
    face_id_time_to_live: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/detect"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_face_id is not None:
        _params["returnFaceId"] = _SERIALIZER.query("return_face_id", return_face_id, "bool")
    if return_face_landmarks is not None:
        _params["returnFaceLandmarks"] = _SERIALIZER.query("return_face_landmarks", return_face_landmarks, "bool")
    if return_face_attributes is not None:
        _params["returnFaceAttributes"] = _SERIALIZER.query("return_face_attributes", return_face_attributes, "str")
    if recognition_model is not None:
        _params["recognitionModel"] = _SERIALIZER.query("recognition_model", recognition_model, "str")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if face_id_time_to_live is not None:
        _params["faceIdTimeToLive"] = _SERIALIZER.query("face_id_time_to_live", face_id_time_to_live, "int")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_find_similar_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/findsimilars"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_verify_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/verify"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_group_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", "v1.1-preview.1")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/face/{apiVersion}/group"
    path_format_arguments = {
        "apiVersion": _SERIALIZER.url("api_version", api_version, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


class FaceListsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.face.FaceClient`'s
        :attr:`face_lists` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create_list(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, resource: _models.FaceList, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.FaceList
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "faceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "persistedFaces": [
                        {
                            "persistedFaceId": "str",  # Face ID of the face. Required.
                            "userData": "str"  # Optional. User-provided data attached to
                              the face. The size limit is 1KB.
                        }
                    ],
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def create_list(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_list(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_list(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, resource: Union[_models.FaceList, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param resource: The resource instance. Is one of the following types: FaceList, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.FaceList or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "faceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "persistedFaces": [
                        {
                            "persistedFaceId": "str",  # Face ID of the face. Required.
                            "userData": "str"  # Optional. User-provided data attached to
                              the face. The size limit is 1KB.
                        }
                    ],
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_lists_create_list_request(
            face_list_id=face_list_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete_list(self, face_list_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_face_lists_delete_list_request(
            face_list_id=face_list_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_list(
        self, face_list_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
    ) -> _models.FaceList:
        # pylint: disable=line-too-long
        """Resource read operation template.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: FaceList. The FaceList is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.FaceList
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "faceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "persistedFaces": [
                        {
                            "persistedFaceId": "str",  # Face ID of the face. Required.
                            "userData": "str"  # Optional. User-provided data attached to
                              the face. The size limit is 1KB.
                        }
                    ],
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FaceList] = kwargs.pop("cls", None)

        _request = build_face_lists_get_list_request(
            face_list_id=face_list_id,
            return_recognition_model=return_recognition_model,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FaceList, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_list(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, resource: _models.FaceList, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.FaceList
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "faceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "persistedFaces": [
                        {
                            "persistedFaceId": "str",  # Face ID of the face. Required.
                            "userData": "str"  # Optional. User-provided data attached to
                              the face. The size limit is 1KB.
                        }
                    ],
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def update_list(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_list(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_list(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, resource: Union[_models.FaceList, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param resource: The resource instance. Is one of the following types: FaceList, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.FaceList or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "faceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "persistedFaces": [
                        {
                            "persistedFaceId": "str",  # Face ID of the face. Required.
                            "userData": "str"  # Optional. User-provided data attached to
                              the face. The size limit is 1KB.
                        }
                    ],
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_lists_update_list_request(
            face_list_id=face_list_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def add_face_from_url(
        self,
        face_list_id: str,
        body: _models.AddFaceFromUrlContent,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param body: Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def add_face_from_url(
        self,
        face_list_id: str,
        body: JSON,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param body: Required.
        :type body: JSON
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def add_face_from_url(
        self,
        face_list_id: str,
        body: IO[bytes],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @distributed_trace
    def add_face_from_url(
        self,
        face_list_id: str,
        body: Union[_models.AddFaceFromUrlContent, JSON, IO[bytes]],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param body: Is one of the following types: AddFaceFromUrlContent, JSON, IO[bytes] Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent or JSON or IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_lists_add_face_from_url_request(
            face_list_id=face_list_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def add_face_from_stream(
        self,
        face_list_id: str,
        image_content: bytes,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_face_lists_add_face_from_stream_request(
            face_list_id=face_list_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_face(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, persisted_face_id: str, **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param face_list_id: ID of the container. Required.
        :type face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_face_lists_delete_face_request(
            face_list_id=face_list_id,
            persisted_face_id=persisted_face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_list(self, *, return_recognition_model: Optional[bool] = None, **kwargs: Any) -> List[_models.FaceList]:
        # pylint: disable=line-too-long
        """Operation that lists resources in a paginated way.

        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: list of FaceList
        :rtype: list[~azure.ai.face.models.FaceList]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "faceListId": "str",  # ID of the container. Required.
                        "name": "str",  # User defined name, maximum length is 128. Required.
                        "persistedFaces": [
                            {
                                "persistedFaceId": "str",  # Face ID of the face.
                                  Required.
                                "userData": "str"  # Optional. User-provided data
                                  attached to the face. The size limit is 1KB.
                            }
                        ],
                        "recognitionModel": "str",  # Optional. Name of recognition model.
                          Recognition model is used when the face features are extracted and associated
                          with detected faceIds. The default value is 'recognition_01', if latest model
                          needed, please explicitly specify the model you need. Known values are:
                          "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                        "userData": "str"  # Optional. Optional user defined data. Length
                          should not exceed 16KB.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.FaceList]] = kwargs.pop("cls", None)

        _request = build_face_lists_list_list_request(
            return_recognition_model=return_recognition_model,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FaceList], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def find_similar_from_face_list(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "faceListId": "str",  # An existing user-specified unique candidate face
                      list, created in FaceList - Create. Face list contains a set of persistedFaceIds
                      which are persisted and will never expire. Required.
                    "maxNumOfCandidatesReturned": 0,  # Optional. The number of top similar faces
                      returned. The valid range is [1, 1000].It defaults to 20.
                    "mode": "str"  # Optional. Similar face searching mode. It can be
                      'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. Known values are:
                      "matchPerson" and "matchFace".
                }

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """

    @overload
    def find_similar_from_face_list(
        self,
        *,
        face_id: str,
        face_list_id: str,
        content_type: str = "application/json",
        max_num_of_candidates_returned: Optional[int] = None,
        mode: Optional[Union[str, _models.FindSimilarMatchMode]] = None,
        **kwargs: Any,
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword face_list_id: An existing user-specified unique candidate face list, created in
         FaceList - Create. Face list contains a set of persistedFaceIds which are persisted and will
         never expire. Required.
        :paramtype face_list_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_num_of_candidates_returned: The number of top similar faces returned. The valid
         range is [1, 1000].It defaults to 20. Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword mode: Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults
         to 'matchPerson'. Known values are: "matchPerson" and "matchFace". Default value is None.
        :paramtype mode: str or ~azure.ai.face.models.FindSimilarMatchMode
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """

    @overload
    def find_similar_from_face_list(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """

    @distributed_trace
    def find_similar_from_face_list(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_id: str = _Unset,
        face_list_id: str = _Unset,
        max_num_of_candidates_returned: Optional[int] = None,
        mode: Optional[Union[str, _models.FindSimilarMatchMode]] = None,
        **kwargs: Any,
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword face_list_id: An existing user-specified unique candidate face list, created in
         FaceList - Create. Face list contains a set of persistedFaceIds which are persisted and will
         never expire. Required.
        :paramtype face_list_id: str
        :keyword max_num_of_candidates_returned: The number of top similar faces returned. The valid
         range is [1, 1000].It defaults to 20. Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword mode: Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults
         to 'matchPerson'. Known values are: "matchPerson" and "matchFace". Default value is None.
        :paramtype mode: str or ~azure.ai.face.models.FindSimilarMatchMode
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "faceListId": "str",  # An existing user-specified unique candidate face
                      list, created in FaceList - Create. Face list contains a set of persistedFaceIds
                      which are persisted and will never expire. Required.
                    "maxNumOfCandidatesReturned": 0,  # Optional. The number of top similar faces
                      returned. The valid range is [1, 1000].It defaults to 20.
                    "mode": "str"  # Optional. Similar face searching mode. It can be
                      'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. Known values are:
                      "matchPerson" and "matchFace".
                }

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.FindSimilarResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_id is _Unset:
                raise TypeError("missing required argument: face_id")
            if face_list_id is _Unset:
                raise TypeError("missing required argument: face_list_id")
            body = {
                "faceid": face_id,
                "facelistid": face_list_id,
                "maxnumofcandidatesreturned": max_num_of_candidates_returned,
                "mode": mode,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_lists_find_similar_from_face_list_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FindSimilarResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class LargeFaceListsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.face.FaceClient`'s
        :attr:`large_face_lists` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create_list(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        resource: _models.LargeFaceList,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.LargeFaceList
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "largeFaceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def create_list(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_list(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_list(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, resource: Union[_models.LargeFaceList, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param resource: The resource instance. Is one of the following types: LargeFaceList, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.LargeFaceList or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "largeFaceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_face_lists_create_list_request(
            large_face_list_id=large_face_list_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete_list(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_face_lists_delete_list_request(
            large_face_list_id=large_face_list_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_list(
        self, large_face_list_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
    ) -> _models.LargeFaceList:
        # pylint: disable=line-too-long
        """Resource read operation template.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: LargeFaceList. The LargeFaceList is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.LargeFaceList
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "largeFaceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargeFaceList] = kwargs.pop("cls", None)

        _request = build_large_face_lists_get_list_request(
            large_face_list_id=large_face_list_id,
            return_recognition_model=return_recognition_model,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargeFaceList, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_list(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        resource: _models.LargeFaceList,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.LargeFaceList
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "largeFaceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def update_list(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_list(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_list(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, resource: Union[_models.LargeFaceList, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param resource: The resource instance. Is one of the following types: LargeFaceList, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.LargeFaceList or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "largeFaceListId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_face_lists_update_list_request(
            large_face_list_id=large_face_list_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def add_face_from_url(
        self,
        large_face_list_id: str,
        body: _models.AddFaceFromUrlContent,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param body: Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def add_face_from_url(
        self,
        large_face_list_id: str,
        body: JSON,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param body: Required.
        :type body: JSON
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def add_face_from_url(
        self,
        large_face_list_id: str,
        body: IO[bytes],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @distributed_trace
    def add_face_from_url(
        self,
        large_face_list_id: str,
        body: Union[_models.AddFaceFromUrlContent, JSON, IO[bytes]],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param body: Is one of the following types: AddFaceFromUrlContent, JSON, IO[bytes] Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent or JSON or IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_face_lists_add_face_from_url_request(
            large_face_list_id=large_face_list_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def add_face_from_stream(
        self,
        large_face_list_id: str,
        image_content: bytes,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_large_face_lists_add_face_from_stream_request(
            large_face_list_id=large_face_list_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_face(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, persisted_face_id: str, **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_face_lists_delete_face_request(
            large_face_list_id=large_face_list_id,
            persisted_face_id=persisted_face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_list(
        self,
        *,
        start: Optional[str] = None,
        top: Optional[int] = None,
        return_recognition_model: Optional[bool] = None,
        **kwargs: Any,
    ) -> List[_models.LargeFaceList]:
        # pylint: disable=line-too-long
        """Operation that lists resources in a paginated way.

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: list of LargeFaceList
        :rtype: list[~azure.ai.face.models.LargeFaceList]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "largeFaceListId": "str",  # ID of the container. Required.
                        "name": "str",  # User defined name, maximum length is 128. Required.
                        "recognitionModel": "str",  # Optional. Name of recognition model.
                          Recognition model is used when the face features are extracted and associated
                          with detected faceIds. The default value is 'recognition_01', if latest model
                          needed, please explicitly specify the model you need. Known values are:
                          "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                        "userData": "str"  # Optional. Optional user defined data. Length
                          should not exceed 16KB.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LargeFaceList]] = kwargs.pop("cls", None)

        _request = build_large_face_lists_list_list_request(
            start=start,
            top=top,
            return_recognition_model=return_recognition_model,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LargeFaceList], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _train_list_initial(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_face_lists_train_list_request(
            large_face_list_id=large_face_list_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def begin_train_list(self, large_face_list_id: str, **kwargs: Any) -> LROPoller[_models.TrainingStatus]:
        # pylint: disable=line-too-long
        """Resource action operation template.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :return: An instance of LROPoller that returns TrainingStatus. The TrainingStatus is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.TrainingStatus]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the created time of the person group, large person group or
                      large face list. Required.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the last modify time of the person group, large person
                      group or large face list, could be null value when the group is not successfully
                      trained. Required.
                    "lastSuccessfulTrainingDateTime": "2020-02-20 00:00:00",  # A combined UTC
                      date and time string that describes the last successful training time of the
                      person group, large person group or large face list. Required.
                    "status": "str",  # Training status of the container. Required. Known values
                      are: "nonstarted", "running", "succeeded", and "failed".
                    "message": "str"  # Optional. Show failure message when training failed
                      (omitted when training succeed).
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrainingStatus] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._train_list_initial(  # type: ignore
                large_face_list_id=large_face_list_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.TrainingStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.TrainingStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.TrainingStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def get_training_status(self, large_face_list_id: str, **kwargs: Any) -> _models.TrainingStatus:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :return: TrainingStatus. The TrainingStatus is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.TrainingStatus
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the created time of the person group, large person group or
                      large face list. Required.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the last modify time of the person group, large person
                      group or large face list, could be null value when the group is not successfully
                      trained. Required.
                    "lastSuccessfulTrainingDateTime": "2020-02-20 00:00:00",  # A combined UTC
                      date and time string that describes the last successful training time of the
                      person group, large person group or large face list. Required.
                    "status": "str",  # Training status of the container. Required. Known values
                      are: "nonstarted", "running", "succeeded", and "failed".
                    "message": "str"  # Optional. Show failure message when training failed
                      (omitted when training succeed).
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrainingStatus] = kwargs.pop("cls", None)

        _request = build_large_face_lists_get_training_status_request(
            large_face_list_id=large_face_list_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TrainingStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_face(self, large_face_list_id: str, persisted_face_id: str, **kwargs: Any) -> _models.LargeFaceListFace:
        """Resource read operation template.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: LargeFaceListFace. The LargeFaceListFace is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.LargeFaceListFace
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargeFaceListFace] = kwargs.pop("cls", None)

        _request = build_large_face_lists_get_face_request(
            large_face_list_id=large_face_list_id,
            persisted_face_id=persisted_face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargeFaceListFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        persisted_face_id: str,
        resource: _models.LargeFaceListFace,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.LargeFaceListFace
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        persisted_face_id: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        persisted_face_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        persisted_face_id: str,
        resource: Union[_models.LargeFaceListFace, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Is one of the following types: LargeFaceListFace, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.LargeFaceListFace or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_face_lists_update_face_request(
            large_face_list_id=large_face_list_id,
            persisted_face_id=persisted_face_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_face(
        self, large_face_list_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LargeFaceListFace]:
        """Operation that lists resources in a paginated way.

        :param large_face_list_id: ID of the container. Required.
        :type large_face_list_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LargeFaceListFace
        :rtype: list[~azure.ai.face.models.LargeFaceListFace]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "persistedFaceId": "str",  # Face ID of the face. Required.
                        "userData": "str"  # Optional. User-provided data attached to the
                          face. The size limit is 1KB.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LargeFaceListFace]] = kwargs.pop("cls", None)

        _request = build_large_face_lists_list_face_request(
            large_face_list_id=large_face_list_id,
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LargeFaceListFace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def find_similar_from_large_face_list(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "largeFaceListId": "str",  # An existing user-specified unique candidate
                      large face list, created in LargeFaceList - Create. Large face list contains a
                      set of persistedFaceIds which are persisted and will never expire. Required.
                    "maxNumOfCandidatesReturned": 0,  # Optional. The number of top similar faces
                      returned. The valid range is [1, 1000].It defaults to 20.
                    "mode": "str"  # Optional. Similar face searching mode. It can be
                      'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. Known values are:
                      "matchPerson" and "matchFace".
                }

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """

    @overload
    def find_similar_from_large_face_list(
        self,
        *,
        face_id: str,
        large_face_list_id: str,
        content_type: str = "application/json",
        max_num_of_candidates_returned: Optional[int] = None,
        mode: Optional[Union[str, _models.FindSimilarMatchMode]] = None,
        **kwargs: Any,
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword large_face_list_id: An existing user-specified unique candidate large face list,
         created in LargeFaceList - Create. Large face list contains a set of persistedFaceIds which are
         persisted and will never expire. Required.
        :paramtype large_face_list_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_num_of_candidates_returned: The number of top similar faces returned. The valid
         range is [1, 1000].It defaults to 20. Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword mode: Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults
         to 'matchPerson'. Known values are: "matchPerson" and "matchFace". Default value is None.
        :paramtype mode: str or ~azure.ai.face.models.FindSimilarMatchMode
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """

    @overload
    def find_similar_from_large_face_list(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """

    @distributed_trace
    def find_similar_from_large_face_list(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_id: str = _Unset,
        large_face_list_id: str = _Unset,
        max_num_of_candidates_returned: Optional[int] = None,
        mode: Optional[Union[str, _models.FindSimilarMatchMode]] = None,
        **kwargs: Any,
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword large_face_list_id: An existing user-specified unique candidate large face list,
         created in LargeFaceList - Create. Large face list contains a set of persistedFaceIds which are
         persisted and will never expire. Required.
        :paramtype large_face_list_id: str
        :keyword max_num_of_candidates_returned: The number of top similar faces returned. The valid
         range is [1, 1000].It defaults to 20. Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword mode: Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults
         to 'matchPerson'. Known values are: "matchPerson" and "matchFace". Default value is None.
        :paramtype mode: str or ~azure.ai.face.models.FindSimilarMatchMode
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "largeFaceListId": "str",  # An existing user-specified unique candidate
                      large face list, created in LargeFaceList - Create. Large face list contains a
                      set of persistedFaceIds which are persisted and will never expire. Required.
                    "maxNumOfCandidatesReturned": 0,  # Optional. The number of top similar faces
                      returned. The valid range is [1, 1000].It defaults to 20.
                    "mode": "str"  # Optional. Similar face searching mode. It can be
                      'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. Known values are:
                      "matchPerson" and "matchFace".
                }

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.FindSimilarResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_id is _Unset:
                raise TypeError("missing required argument: face_id")
            if large_face_list_id is _Unset:
                raise TypeError("missing required argument: large_face_list_id")
            body = {
                "faceid": face_id,
                "largefacelistid": large_face_list_id,
                "maxnumofcandidatesreturned": max_num_of_candidates_returned,
                "mode": mode,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_face_lists_find_similar_from_large_face_list_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FindSimilarResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class FaceAsyncOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.face.FaceClient`'s
        :attr:`face_async_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_status(self, operation_id: str, **kwargs: Any) -> _models.AsyncOperationStatus:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param operation_id: The operation ID, which can be found from the 'Operation-Location'
         response header in the initial request. Required.
        :type operation_id: str
        :return: AsyncOperationStatus. The AsyncOperationStatus is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AsyncOperationStatus
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Date and time the operation was
                      created. Required.
                    "status": "str",  # Current status of the operation. Required. Known values
                      are: "notstarted", "running", "succeeded", and "failed".
                    "finishedDateTime": "2020-02-20 00:00:00",  # Optional. Date and time the
                      operation was finished.
                    "message": "str"  # Optional. Message for the operation.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AsyncOperationStatus] = kwargs.pop("cls", None)

        _request = build_face_async_operations_get_status_request(
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AsyncOperationStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class PersonDirectoryPersonsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.face.FaceClient`'s
        :attr:`person_directory_persons` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_person_initial(
        self, resource: Union[_models.PersonDirectoryPerson, JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directory_persons_create_person_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["operation-Location"] = self._deserialize("str", response.headers.get("operation-Location"))

        deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_person(
        self, resource: _models.PersonDirectoryPerson, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.CreatePersonResult]:
        """Operation that applies to a collection of resources.

        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.PersonDirectoryPerson
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns CreatePersonResult. The CreatePersonResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.CreatePersonResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # Person ID of the person. Required.
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }

                # response body for status code(s): 202
                response == {
                    "personId": "str"  # Person ID of the person. Required.
                }
        """

    @overload
    def begin_create_person(
        self, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.CreatePersonResult]:
        """Operation that applies to a collection of resources.

        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns CreatePersonResult. The CreatePersonResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.CreatePersonResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "personId": "str"  # Person ID of the person. Required.
                }
        """

    @overload
    def begin_create_person(
        self, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.CreatePersonResult]:
        """Operation that applies to a collection of resources.

        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns CreatePersonResult. The CreatePersonResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.CreatePersonResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "personId": "str"  # Person ID of the person. Required.
                }
        """

    @distributed_trace
    def begin_create_person(
        self, resource: Union[_models.PersonDirectoryPerson, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.CreatePersonResult]:
        """Operation that applies to a collection of resources.

        :param resource: The resource instance. Is one of the following types: PersonDirectoryPerson,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.face.models.PersonDirectoryPerson or JSON or IO[bytes]
        :return: An instance of LROPoller that returns CreatePersonResult. The CreatePersonResult is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.CreatePersonResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # Person ID of the person. Required.
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }

                # response body for status code(s): 202
                response == {
                    "personId": "str"  # Person ID of the person. Required.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreatePersonResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_person_initial(
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["operation-Location"] = self._deserialize(
                "str", response.headers.get("operation-Location")
            )

            deserialized = _deserialize(_models.CreatePersonResult, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.CreatePersonResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.CreatePersonResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_person_initial(  # pylint: disable=inconsistent-return-statements
        self, person_id: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_directory_persons_delete_person_request(
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["operation-Location"] = self._deserialize("str", response.headers.get("operation-Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete_person(self, person_id: str, **kwargs: Any) -> LROPoller[_models.AsyncOperationStatus]:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :return: An instance of LROPoller that returns AsyncOperationStatus. The AsyncOperationStatus
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.AsyncOperationStatus]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Date and time the operation was
                      created. Required.
                    "status": "str",  # Current status of the operation. Required. Known values
                      are: "notstarted", "running", "succeeded", and "failed".
                    "finishedDateTime": "2020-02-20 00:00:00",  # Optional. Date and time the
                      operation was finished.
                    "message": "str"  # Optional. Message for the operation.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AsyncOperationStatus] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_person_initial(  # type: ignore
                person_id=person_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["operation-Location"] = self._deserialize(
                "str", response.headers.get("operation-Location")
            )

            deserialized = _deserialize(_models.AsyncOperationStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AsyncOperationStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AsyncOperationStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def get_person(self, person_id: str, **kwargs: Any) -> _models.PersonDirectoryPerson:
        """Resource read operation template.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :return: PersonDirectoryPerson. The PersonDirectoryPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.PersonDirectoryPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # Person ID of the person. Required.
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonDirectoryPerson] = kwargs.pop("cls", None)

        _request = build_person_directory_persons_get_person_request(
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        person_id: str,
        resource: _models.PersonDirectoryPerson,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.PersonDirectoryPerson
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # Person ID of the person. Required.
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self, person_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self, person_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_person(  # pylint: disable=inconsistent-return-statements
        self, person_id: str, resource: Union[_models.PersonDirectoryPerson, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectoryPerson,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.face.models.PersonDirectoryPerson or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # Person ID of the person. Required.
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directory_persons_update_person_request(
            person_id=person_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_person(
        self, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.PersonDirectoryPerson]:
        """Operation that lists resources in a paginated way.

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of PersonDirectoryPerson
        :rtype: list[~azure.ai.face.models.PersonDirectoryPerson]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "name": "str",  # User defined name, maximum length is 128. Required.
                        "personId": "str",  # Person ID of the person. Required.
                        "userData": "str"  # Optional. Optional user defined data. Length
                          should not exceed 16KB.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonDirectoryPerson]] = kwargs.pop("cls", None)

        _request = build_person_directory_persons_list_person_request(
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.PersonDirectoryPerson], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_group_reference(
        self, person_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> _models.ListGroupReferenceResult:
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: ListGroupReferenceResult. The ListGroupReferenceResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.ListGroupReferenceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dynamicPersonGroupIds": [
                        "str"  # Array of PersonDirectory DynamicPersonGroup ids. Required.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListGroupReferenceResult] = kwargs.pop("cls", None)

        _request = build_person_directory_persons_list_group_reference_request(
            person_id=person_id,
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListGroupReferenceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _add_face_from_url_initial(
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        body: Union[_models.AddFaceFromUrlContent, JSON, IO[bytes]],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directory_persons_add_face_from_url_request(
            person_id=person_id,
            recognition_model=recognition_model,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["operation-Location"] = self._deserialize("str", response.headers.get("operation-Location"))

        deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_add_face_from_url(
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        body: _models.AddFaceFromUrlContent,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.AddFaceResult]:
        """Operation that applies to a collection of resources.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param body: The body type of the operation request or response. Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AddFaceResult. The AddFaceResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.AddFaceResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 202
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def begin_add_face_from_url(
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        body: JSON,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.AddFaceResult]:
        """Operation that applies to a collection of resources.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param body: The body type of the operation request or response. Required.
        :type body: JSON
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AddFaceResult. The AddFaceResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.AddFaceResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def begin_add_face_from_url(
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        body: IO[bytes],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.AddFaceResult]:
        """Operation that applies to a collection of resources.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param body: The body type of the operation request or response. Required.
        :type body: IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns AddFaceResult. The AddFaceResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.AddFaceResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @distributed_trace
    def begin_add_face_from_url(
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        body: Union[_models.AddFaceFromUrlContent, JSON, IO[bytes]],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> LROPoller[_models.AddFaceResult]:
        """Operation that applies to a collection of resources.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param body: The body type of the operation request or response. Is one of the following types:
         AddFaceFromUrlContent, JSON, IO[bytes] Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent or JSON or IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: An instance of LROPoller that returns AddFaceResult. The AddFaceResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.AddFaceResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 202
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._add_face_from_url_initial(
                person_id=person_id,
                recognition_model=recognition_model,
                body=body,
                target_face=target_face,
                detection_model=detection_model,
                user_data=user_data,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["operation-Location"] = self._deserialize(
                "str", response.headers.get("operation-Location")
            )

            deserialized = _deserialize(_models.AddFaceResult, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AddFaceResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AddFaceResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _add_face_from_stream_initial(
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        image_content: bytes,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_person_directory_persons_add_face_from_stream_request(
            person_id=person_id,
            recognition_model=recognition_model,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["operation-Location"] = self._deserialize("str", response.headers.get("operation-Location"))

        deserialized = _deserialize(JSON, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_add_face_from_stream(
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        image_content: bytes,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> LROPoller[_models.AddFaceResult]:
        """Operation that applies to a collection of resources.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: An instance of LROPoller that returns AddFaceResult. The AddFaceResult is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.AddFaceResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._add_face_from_stream_initial(
                person_id=person_id,
                recognition_model=recognition_model,
                image_content=image_content,
                target_face=target_face,
                detection_model=detection_model,
                user_data=user_data,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["operation-Location"] = self._deserialize(
                "str", response.headers.get("operation-Location")
            )

            deserialized = _deserialize(_models.AddFaceResult, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AddFaceResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AddFaceResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_face_initial(  # pylint: disable=inconsistent-return-statements
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        persisted_face_id: str,
        **kwargs: Any,
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_directory_persons_delete_face_request(
            person_id=person_id,
            recognition_model=recognition_model,
            persisted_face_id=persisted_face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["operation-Location"] = self._deserialize("str", response.headers.get("operation-Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete_face(
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        persisted_face_id: str,
        **kwargs: Any,
    ) -> LROPoller[_models.AsyncOperationStatus]:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: An instance of LROPoller that returns AsyncOperationStatus. The AsyncOperationStatus
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.AsyncOperationStatus]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Date and time the operation was
                      created. Required.
                    "status": "str",  # Current status of the operation. Required. Known values
                      are: "notstarted", "running", "succeeded", and "failed".
                    "finishedDateTime": "2020-02-20 00:00:00",  # Optional. Date and time the
                      operation was finished.
                    "message": "str"  # Optional. Message for the operation.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AsyncOperationStatus] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_face_initial(  # type: ignore
                person_id=person_id,
                recognition_model=recognition_model,
                persisted_face_id=persisted_face_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["operation-Location"] = self._deserialize(
                "str", response.headers.get("operation-Location")
            )

            deserialized = _deserialize(_models.AsyncOperationStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AsyncOperationStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AsyncOperationStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def get_face(
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        persisted_face_id: str,
        **kwargs: Any,
    ) -> _models.PersonDirectoryFace:
        """Resource read operation template.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: PersonDirectoryFace. The PersonDirectoryFace is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.PersonDirectoryFace
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonDirectoryFace] = kwargs.pop("cls", None)

        _request = build_person_directory_persons_get_face_request(
            person_id=person_id,
            recognition_model=recognition_model,
            persisted_face_id=persisted_face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonDirectoryFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        persisted_face_id: str,
        resource: _models.PersonDirectoryFace,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.PersonDirectoryFace
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        persisted_face_id: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        persisted_face_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_id: str,
        recognition_model: Union[str, _models.RecognitionModel],
        persisted_face_id: str,
        resource: Union[_models.PersonDirectoryFace, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Is one of the following types: PersonDirectoryFace,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.face.models.PersonDirectoryFace or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directory_persons_update_face_request(
            person_id=person_id,
            recognition_model=recognition_model,
            persisted_face_id=persisted_face_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_face(
        self, person_id: str, recognition_model: Union[str, _models.RecognitionModel], **kwargs: Any
    ) -> _models.ListFaceResult:
        """Operation that lists resources in a paginated way.

        :param person_id: Person ID of the person. Required.
        :type person_id: str
        :param recognition_model: The 'recognitionModel' associated with faces. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Required.
        :type recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :return: ListFaceResult. The ListFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.ListFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceIds": [
                        "str"  # Array of persisted face ids. Required.
                    ],
                    "personId": "str"  # Id of person. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListFaceResult] = kwargs.pop("cls", None)

        _request = build_person_directory_persons_list_face_request(
            person_id=person_id,
            recognition_model=recognition_model,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def identify_from_person_directory(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"  # Array of query faces faceIds, created by the Face - Detect.
                          Each of the faces are identified independently. The valid number of faceIds
                          is between [1, 10]. Required.
                    ],
                    "personIds": [
                        "str"  # Array of personIds created in PersonDirectory -
                          PersonCreate. The valid number of personIds is between [1,30]. Required.
                    ],
                    "confidenceThreshold": 0.0,  # Optional. Customized identification confidence
                      threshold, in the range of [0, 1]. Advanced user can tweak this value to override
                      default internal threshold for better precision on their scenario data. Note
                      there is no guarantee of this threshold value working on other data and after
                      algorithm updates.
                    "maxNumOfCandidatesReturned": 0  # Optional. The range of
                      maxNumOfCandidatesReturned is between 1 and 100 (default is 10).
                }

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @overload
    def identify_from_person_directory(
        self,
        *,
        face_ids: List[str],
        person_ids: List[str],
        content_type: str = "application/json",
        max_num_of_candidates_returned: Optional[int] = None,
        confidence_threshold: Optional[float] = None,
        **kwargs: Any,
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :keyword face_ids: Array of query faces faceIds, created by the Face - Detect. Each of the
         faces are identified independently. The valid number of faceIds is between [1, 10]. Required.
        :paramtype face_ids: list[str]
        :keyword person_ids: Array of personIds created in PersonDirectory - PersonCreate. The valid
         number of personIds is between [1,30]. Required.
        :paramtype person_ids: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_num_of_candidates_returned: The range of maxNumOfCandidatesReturned is between 1
         and 100 (default is 10). Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword confidence_threshold: Customized identification confidence threshold, in the range of
         [0, 1]. Advanced user can tweak this value to override default internal threshold for better
         precision on their scenario data. Note there is no guarantee of this threshold value working on
         other data and after algorithm updates. Default value is None.
        :paramtype confidence_threshold: float
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @overload
    def identify_from_person_directory(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @distributed_trace
    def identify_from_person_directory(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_ids: List[str] = _Unset,
        person_ids: List[str] = _Unset,
        max_num_of_candidates_returned: Optional[int] = None,
        confidence_threshold: Optional[float] = None,
        **kwargs: Any,
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_ids: Array of query faces faceIds, created by the Face - Detect. Each of the
         faces are identified independently. The valid number of faceIds is between [1, 10]. Required.
        :paramtype face_ids: list[str]
        :keyword person_ids: Array of personIds created in PersonDirectory - PersonCreate. The valid
         number of personIds is between [1,30]. Required.
        :paramtype person_ids: list[str]
        :keyword max_num_of_candidates_returned: The range of maxNumOfCandidatesReturned is between 1
         and 100 (default is 10). Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword confidence_threshold: Customized identification confidence threshold, in the range of
         [0, 1]. Advanced user can tweak this value to override default internal threshold for better
         precision on their scenario data. Note there is no guarantee of this threshold value working on
         other data and after algorithm updates. Default value is None.
        :paramtype confidence_threshold: float
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"  # Array of query faces faceIds, created by the Face - Detect.
                          Each of the faces are identified independently. The valid number of faceIds
                          is between [1, 10]. Required.
                    ],
                    "personIds": [
                        "str"  # Array of personIds created in PersonDirectory -
                          PersonCreate. The valid number of personIds is between [1,30]. Required.
                    ],
                    "confidenceThreshold": 0.0,  # Optional. Customized identification confidence
                      threshold, in the range of [0, 1]. Advanced user can tweak this value to override
                      default internal threshold for better precision on their scenario data. Note
                      there is no guarantee of this threshold value working on other data and after
                      algorithm updates.
                    "maxNumOfCandidatesReturned": 0  # Optional. The range of
                      maxNumOfCandidatesReturned is between 1 and 100 (default is 10).
                }

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.IdentifyResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_ids is _Unset:
                raise TypeError("missing required argument: face_ids")
            if person_ids is _Unset:
                raise TypeError("missing required argument: person_ids")
            body = {
                "confidencethreshold": confidence_threshold,
                "faceids": face_ids,
                "maxnumofcandidatesreturned": max_num_of_candidates_returned,
                "personids": person_ids,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directory_persons_identify_from_person_directory_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.IdentifyResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def verify_from_person_directory(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "personId": "str"  # Specify a certain person in PersonDirectory Person.
                      Required.
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @overload
    def verify_from_person_directory(
        self, *, face_id: str, person_id: str, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword person_id: Specify a certain person in PersonDirectory Person. Required.
        :paramtype person_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @overload
    def verify_from_person_directory(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @distributed_trace
    def verify_from_person_directory(
        self, body: Union[JSON, IO[bytes]] = _Unset, *, face_id: str = _Unset, person_id: str = _Unset, **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword person_id: Specify a certain person in PersonDirectory Person. Required.
        :paramtype person_id: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "personId": "str"  # Specify a certain person in PersonDirectory Person.
                      Required.
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VerifyResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_id is _Unset:
                raise TypeError("missing required argument: face_id")
            if person_id is _Unset:
                raise TypeError("missing required argument: person_id")
            body = {"faceid": face_id, "personid": person_id}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directory_persons_verify_from_person_directory_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VerifyResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class PersonDirectoryDynamicPersonGroupsOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.face.FaceClient`'s
        :attr:`person_directory_dynamic_person_groups` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_group_initial(  # pylint: disable=inconsistent-return-statements
        self, dynamic_person_group_id: str, resource: Union[_models.DynamicPersonGroup, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directory_dynamic_person_groups_create_group_request(
            dynamic_person_group_id=dynamic_person_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 202:
            response_headers["operation-Location"] = self._deserialize(
                "str", response.headers.get("operation-Location")
            )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @overload
    def begin_create_group(
        self,
        dynamic_person_group_id: str,
        resource: _models.DynamicPersonGroup,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.DynamicPersonGroup]:
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.DynamicPersonGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns DynamicPersonGroup. The DynamicPersonGroup is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.DynamicPersonGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "dynamicPersonGroupId": "str",  # ID of the dynamic person group. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "addPersonIds": [
                        "str"  # Optional. Array of personIds created by PersonDirectory
                          Person - Create to add.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }

                # response body for status code(s): 200
                response == {
                    "dynamicPersonGroupId": "str",  # ID of the dynamic person group. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "addPersonIds": [
                        "str"  # Optional. Array of personIds created by PersonDirectory
                          Person - Create to add.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def begin_create_group(
        self, dynamic_person_group_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.DynamicPersonGroup]:
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns DynamicPersonGroup. The DynamicPersonGroup is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.DynamicPersonGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dynamicPersonGroupId": "str",  # ID of the dynamic person group. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "addPersonIds": [
                        "str"  # Optional. Array of personIds created by PersonDirectory
                          Person - Create to add.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def begin_create_group(
        self,
        dynamic_person_group_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.DynamicPersonGroup]:
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns DynamicPersonGroup. The DynamicPersonGroup is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.DynamicPersonGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dynamicPersonGroupId": "str",  # ID of the dynamic person group. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "addPersonIds": [
                        "str"  # Optional. Array of personIds created by PersonDirectory
                          Person - Create to add.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @distributed_trace
    def begin_create_group(
        self, dynamic_person_group_id: str, resource: Union[_models.DynamicPersonGroup, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.DynamicPersonGroup]:
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :param resource: The resource instance. Is one of the following types: DynamicPersonGroup,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.face.models.DynamicPersonGroup or JSON or IO[bytes]
        :return: An instance of LROPoller that returns DynamicPersonGroup. The DynamicPersonGroup is
         compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.DynamicPersonGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "dynamicPersonGroupId": "str",  # ID of the dynamic person group. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "addPersonIds": [
                        "str"  # Optional. Array of personIds created by PersonDirectory
                          Person - Create to add.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }

                # response body for status code(s): 200
                response == {
                    "dynamicPersonGroupId": "str",  # ID of the dynamic person group. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "addPersonIds": [
                        "str"  # Optional. Array of personIds created by PersonDirectory
                          Person - Create to add.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DynamicPersonGroup] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_group_initial(  # type: ignore
                dynamic_person_group_id=dynamic_person_group_id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.DynamicPersonGroup, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.DynamicPersonGroup].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.DynamicPersonGroup](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _delete_group_initial(  # pylint: disable=inconsistent-return-statements
        self, dynamic_person_group_id: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_directory_dynamic_person_groups_delete_group_request(
            dynamic_person_group_id=dynamic_person_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["operation-Location"] = self._deserialize("str", response.headers.get("operation-Location"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace
    def begin_delete_group(
        self, dynamic_person_group_id: str, **kwargs: Any
    ) -> LROPoller[_models.AsyncOperationStatus]:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :return: An instance of LROPoller that returns AsyncOperationStatus. The AsyncOperationStatus
         is compatible with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.AsyncOperationStatus]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Date and time the operation was
                      created. Required.
                    "status": "str",  # Current status of the operation. Required. Known values
                      are: "notstarted", "running", "succeeded", and "failed".
                    "finishedDateTime": "2020-02-20 00:00:00",  # Optional. Date and time the
                      operation was finished.
                    "message": "str"  # Optional. Message for the operation.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AsyncOperationStatus] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_group_initial(  # type: ignore
                dynamic_person_group_id=dynamic_person_group_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers["operation-Location"] = self._deserialize(
                "str", response.headers.get("operation-Location")
            )

            deserialized = _deserialize(_models.AsyncOperationStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, response_headers)  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.AsyncOperationStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.AsyncOperationStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def get_group(self, dynamic_person_group_id: str, **kwargs: Any) -> _models.DynamicPersonGroup:
        """Resource read operation template.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :return: DynamicPersonGroup. The DynamicPersonGroup is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.DynamicPersonGroup
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "dynamicPersonGroupId": "str",  # ID of the dynamic person group. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "addPersonIds": [
                        "str"  # Optional. Array of personIds created by PersonDirectory
                          Person - Create to add.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DynamicPersonGroup] = kwargs.pop("cls", None)

        _request = build_person_directory_dynamic_person_groups_get_group_request(
            dynamic_person_group_id=dynamic_person_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DynamicPersonGroup, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _update_group_initial(  # pylint: disable=inconsistent-return-statements
        self, dynamic_person_group_id: str, resource: Union[_models.DynamicPersonGroup, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directory_dynamic_person_groups_update_group_request(
            dynamic_person_group_id=dynamic_person_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        if response.status_code == 202:
            response_headers["operation-Location"] = self._deserialize(
                "str", response.headers.get("operation-Location")
            )

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @overload
    def begin_update_group(
        self,
        dynamic_person_group_id: str,
        resource: _models.DynamicPersonGroup,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.OkResponse]:
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.DynamicPersonGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns OkResponse. The OkResponse is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.OkResponse]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "dynamicPersonGroupId": "str",  # ID of the dynamic person group. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "addPersonIds": [
                        "str"  # Optional. Array of personIds created by PersonDirectory
                          Person - Create to add.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def begin_update_group(
        self, dynamic_person_group_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[_models.OkResponse]:
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns OkResponse. The OkResponse is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.OkResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_update_group(
        self,
        dynamic_person_group_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[_models.OkResponse]:
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns OkResponse. The OkResponse is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.OkResponse]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_update_group(
        self, dynamic_person_group_id: str, resource: Union[_models.DynamicPersonGroup, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[_models.OkResponse]:
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :param resource: The resource instance. Is one of the following types: DynamicPersonGroup,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.face.models.DynamicPersonGroup or JSON or IO[bytes]
        :return: An instance of LROPoller that returns OkResponse. The OkResponse is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.OkResponse]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "dynamicPersonGroupId": "str",  # ID of the dynamic person group. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "addPersonIds": [
                        "str"  # Optional. Array of personIds created by PersonDirectory
                          Person - Create to add.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.OkResponse] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_group_initial(  # type: ignore
                dynamic_person_group_id=dynamic_person_group_id,
                resource=resource,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.OkResponse, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.OkResponse].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.OkResponse](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def list_group(
        self, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.DynamicPersonGroup]:
        """Operation that lists resources in a paginated way.

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of DynamicPersonGroup
        :rtype: list[~azure.ai.face.models.DynamicPersonGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "dynamicPersonGroupId": "str",  # ID of the dynamic person group.
                          Required.
                        "name": "str",  # User defined name, maximum length is 128. Required.
                        "addPersonIds": [
                            "str"  # Optional. Array of personIds created by
                              PersonDirectory Person - Create to add.
                        ],
                        "userData": "str"  # Optional. Optional user defined data. Length
                          should not exceed 16KB.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DynamicPersonGroup]] = kwargs.pop("cls", None)

        _request = build_person_directory_dynamic_person_groups_list_group_request(
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.DynamicPersonGroup], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_group_person(
        self, dynamic_person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> _models.ListPersonResult:
        """The most basic operation that applies to a resource.

        :param dynamic_person_group_id: ID of the dynamic person group. Required.
        :type dynamic_person_group_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: ListPersonResult. The ListPersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.ListPersonResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "personIds": [
                        "str"  # Array of PersonDirectory Person ids. Required.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ListPersonResult] = kwargs.pop("cls", None)

        _request = build_person_directory_dynamic_person_groups_list_group_person_request(
            dynamic_person_group_id=dynamic_person_group_id,
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ListPersonResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def identify_from_dynamic_person_group(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "dynamicPersonGroupId": "str",  # Id of the target PersonDirectory
                      DynamicPersonGroup to match against. Required.
                    "faceIds": [
                        "str"  # Array of query faces faceIds, created by the Face - Detect.
                          Each of the faces are identified independently. The valid number of faceIds
                          is between [1, 10]. Required.
                    ],
                    "confidenceThreshold": 0.0,  # Optional. Customized identification confidence
                      threshold, in the range of [0, 1]. Advanced user can tweak this value to override
                      default internal threshold for better precision on their scenario data. Note
                      there is no guarantee of this threshold value working on other data and after
                      algorithm updates.
                    "maxNumOfCandidatesReturned": 0  # Optional. The range of
                      maxNumOfCandidatesReturned is between 1 and 100 (default is 10).
                }

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @overload
    def identify_from_dynamic_person_group(
        self,
        *,
        face_ids: List[str],
        dynamic_person_group_id: str,
        content_type: str = "application/json",
        max_num_of_candidates_returned: Optional[int] = None,
        confidence_threshold: Optional[float] = None,
        **kwargs: Any,
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :keyword face_ids: Array of query faces faceIds, created by the Face - Detect. Each of the
         faces are identified independently. The valid number of faceIds is between [1, 10]. Required.
        :paramtype face_ids: list[str]
        :keyword dynamic_person_group_id: Id of the target PersonDirectory DynamicPersonGroup to match
         against. Required.
        :paramtype dynamic_person_group_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_num_of_candidates_returned: The range of maxNumOfCandidatesReturned is between 1
         and 100 (default is 10). Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword confidence_threshold: Customized identification confidence threshold, in the range of
         [0, 1]. Advanced user can tweak this value to override default internal threshold for better
         precision on their scenario data. Note there is no guarantee of this threshold value working on
         other data and after algorithm updates. Default value is None.
        :paramtype confidence_threshold: float
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @overload
    def identify_from_dynamic_person_group(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @distributed_trace
    def identify_from_dynamic_person_group(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_ids: List[str] = _Unset,
        dynamic_person_group_id: str = _Unset,
        max_num_of_candidates_returned: Optional[int] = None,
        confidence_threshold: Optional[float] = None,
        **kwargs: Any,
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_ids: Array of query faces faceIds, created by the Face - Detect. Each of the
         faces are identified independently. The valid number of faceIds is between [1, 10]. Required.
        :paramtype face_ids: list[str]
        :keyword dynamic_person_group_id: Id of the target PersonDirectory DynamicPersonGroup to match
         against. Required.
        :paramtype dynamic_person_group_id: str
        :keyword max_num_of_candidates_returned: The range of maxNumOfCandidatesReturned is between 1
         and 100 (default is 10). Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword confidence_threshold: Customized identification confidence threshold, in the range of
         [0, 1]. Advanced user can tweak this value to override default internal threshold for better
         precision on their scenario data. Note there is no guarantee of this threshold value working on
         other data and after algorithm updates. Default value is None.
        :paramtype confidence_threshold: float
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "dynamicPersonGroupId": "str",  # Id of the target PersonDirectory
                      DynamicPersonGroup to match against. Required.
                    "faceIds": [
                        "str"  # Array of query faces faceIds, created by the Face - Detect.
                          Each of the faces are identified independently. The valid number of faceIds
                          is between [1, 10]. Required.
                    ],
                    "confidenceThreshold": 0.0,  # Optional. Customized identification confidence
                      threshold, in the range of [0, 1]. Advanced user can tweak this value to override
                      default internal threshold for better precision on their scenario data. Note
                      there is no guarantee of this threshold value working on other data and after
                      algorithm updates.
                    "maxNumOfCandidatesReturned": 0  # Optional. The range of
                      maxNumOfCandidatesReturned is between 1 and 100 (default is 10).
                }

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.IdentifyResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_ids is _Unset:
                raise TypeError("missing required argument: face_ids")
            if dynamic_person_group_id is _Unset:
                raise TypeError("missing required argument: dynamic_person_group_id")
            body = {
                "confidencethreshold": confidence_threshold,
                "dynamicpersongroupid": dynamic_person_group_id,
                "faceids": face_ids,
                "maxnumofcandidatesreturned": max_num_of_candidates_returned,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_directory_dynamic_person_groups_identify_from_dynamic_person_group_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.IdentifyResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class PersonGroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.face.FaceClient`'s
        :attr:`person_groups` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create_group(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        resource: _models.PersonGroup,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.PersonGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personGroupId": "str",  # ID of the container. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def create_group(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_group(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_group(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, resource: Union[_models.PersonGroup, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Is one of the following types: PersonGroup, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.PersonGroup or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personGroupId": "str",  # ID of the container. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_create_group_request(
            person_group_id=person_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete_group(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_groups_delete_group_request(
            person_group_id=person_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_group(
        self, person_group_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
    ) -> _models.PersonGroup:
        # pylint: disable=line-too-long
        """Resource read operation template.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: PersonGroup. The PersonGroup is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.PersonGroup
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personGroupId": "str",  # ID of the container. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonGroup] = kwargs.pop("cls", None)

        _request = build_person_groups_get_group_request(
            person_group_id=person_group_id,
            return_recognition_model=return_recognition_model,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonGroup, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_group(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        resource: _models.PersonGroup,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.PersonGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personGroupId": "str",  # ID of the container. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def update_group(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_group(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_group(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, resource: Union[_models.PersonGroup, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Is one of the following types: PersonGroup, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.PersonGroup or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personGroupId": "str",  # ID of the container. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_update_group_request(
            person_group_id=person_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_group(
        self,
        *,
        start: Optional[str] = None,
        top: Optional[int] = None,
        return_recognition_model: Optional[bool] = None,
        **kwargs: Any,
    ) -> List[_models.PersonGroup]:
        # pylint: disable=line-too-long
        """Operation that lists resources in a paginated way.

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: list of PersonGroup
        :rtype: list[~azure.ai.face.models.PersonGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "name": "str",  # User defined name, maximum length is 128. Required.
                        "personGroupId": "str",  # ID of the container. Required.
                        "recognitionModel": "str",  # Optional. Name of recognition model.
                          Recognition model is used when the face features are extracted and associated
                          with detected faceIds. The default value is 'recognition_01', if latest model
                          needed, please explicitly specify the model you need. Known values are:
                          "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                        "userData": "str"  # Optional. Optional user defined data. Length
                          should not exceed 16KB.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonGroup]] = kwargs.pop("cls", None)

        _request = build_person_groups_list_group_request(
            start=start,
            top=top,
            return_recognition_model=return_recognition_model,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.PersonGroup], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_person(
        self,
        person_group_id: str,
        resource: _models.PersonGroupPerson,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.PersonGroupPerson:
        """Operation that applies to a collection of resources.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.PersonGroupPerson
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonGroupPerson. The PersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.PersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def create_person(
        self, person_group_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonGroupPerson:
        """Operation that applies to a collection of resources.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonGroupPerson. The PersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.PersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def create_person(
        self, person_group_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PersonGroupPerson:
        """Operation that applies to a collection of resources.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PersonGroupPerson. The PersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.PersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @distributed_trace
    def create_person(
        self, person_group_id: str, resource: Union[_models.PersonGroupPerson, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.PersonGroupPerson:
        """Operation that applies to a collection of resources.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param resource: The resource instance. Is one of the following types: PersonGroupPerson, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.PersonGroupPerson or JSON or IO[bytes]
        :return: PersonGroupPerson. The PersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.PersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PersonGroupPerson] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_create_person_request(
            person_group_id=person_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonGroupPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_person(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, person_id: str, **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_groups_delete_person_request(
            person_group_id=person_group_id,
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_person(self, person_group_id: str, person_id: str, **kwargs: Any) -> _models.PersonGroupPerson:
        """Resource read operation template.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :return: PersonGroupPerson. The PersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.PersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonGroupPerson] = kwargs.pop("cls", None)

        _request = build_person_groups_get_person_request(
            person_group_id=person_group_id,
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonGroupPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        resource: _models.PersonGroupPerson,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.PersonGroupPerson
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        resource: Union[_models.PersonGroupPerson, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Is one of the following types: PersonGroupPerson, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.PersonGroupPerson or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_update_person_request(
            person_group_id=person_group_id,
            person_id=person_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_person(
        self, person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.PersonGroupPerson]:
        """Operation that lists resources in a paginated way.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of PersonGroupPerson
        :rtype: list[~azure.ai.face.models.PersonGroupPerson]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "name": "str",  # User defined name, maximum length is 128. Required.
                        "personId": "str",  # ID of the person. Required.
                        "persistedFaceIds": [
                            "str"  # Optional. Face ids of registered faces in the
                              person.
                        ],
                        "userData": "str"  # Optional. Optional user defined data. Length
                          should not exceed 16KB.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonGroupPerson]] = kwargs.pop("cls", None)

        _request = build_person_groups_list_person_request(
            person_group_id=person_group_id,
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.PersonGroupPerson], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def add_face_from_url(
        self,
        person_group_id: str,
        person_id: str,
        body: _models.AddFaceFromUrlContent,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def add_face_from_url(
        self,
        person_group_id: str,
        person_id: str,
        body: JSON,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: JSON
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def add_face_from_url(
        self,
        person_group_id: str,
        person_id: str,
        body: IO[bytes],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @distributed_trace
    def add_face_from_url(
        self,
        person_group_id: str,
        person_id: str,
        body: Union[_models.AddFaceFromUrlContent, JSON, IO[bytes]],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Is one of the following types: AddFaceFromUrlContent, JSON, IO[bytes] Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent or JSON or IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_add_face_from_url_request(
            person_group_id=person_group_id,
            person_id=person_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def add_face_from_stream(
        self,
        person_group_id: str,
        person_id: str,
        image_content: bytes,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_person_groups_add_face_from_stream_request(
            person_group_id=person_group_id,
            person_id=person_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_face(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_groups_delete_face_request(
            person_group_id=person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_face(
        self, person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
    ) -> _models.PersonGroupPersonFace:
        """Resource read operation template.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: PersonGroupPersonFace. The PersonGroupPersonFace is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.PersonGroupPersonFace
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonGroupPersonFace] = kwargs.pop("cls", None)

        _request = build_person_groups_get_face_request(
            person_group_id=person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonGroupPersonFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        resource: _models.PersonGroupPersonFace,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.PersonGroupPersonFace
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        resource: Union[_models.PersonGroupPersonFace, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Is one of the following types: PersonGroupPersonFace,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.face.models.PersonGroupPersonFace or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_update_face_request(
            person_group_id=person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def identify_from_person_group(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"  # Array of query faces faceIds, created by the Face - Detect.
                          Each of the faces are identified independently. The valid number of faceIds
                          is between [1, 10]. Required.
                    ],
                    "personGroupId": "str",  # Id of the target person group, created by
                      PersonGroup - Create. Required.
                    "confidenceThreshold": 0.0,  # Optional. Customized identification confidence
                      threshold, in the range of [0, 1]. Advanced user can tweak this value to override
                      default internal threshold for better precision on their scenario data. Note
                      there is no guarantee of this threshold value working on other data and after
                      algorithm updates.
                    "maxNumOfCandidatesReturned": 0  # Optional. The range of
                      maxNumOfCandidatesReturned is between 1 and 100 (default is 10).
                }

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @overload
    def identify_from_person_group(
        self,
        *,
        face_ids: List[str],
        person_group_id: str,
        content_type: str = "application/json",
        max_num_of_candidates_returned: Optional[int] = None,
        confidence_threshold: Optional[float] = None,
        **kwargs: Any,
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :keyword face_ids: Array of query faces faceIds, created by the Face - Detect. Each of the
         faces are identified independently. The valid number of faceIds is between [1, 10]. Required.
        :paramtype face_ids: list[str]
        :keyword person_group_id: Id of the target person group, created by PersonGroup - Create.
         Required.
        :paramtype person_group_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_num_of_candidates_returned: The range of maxNumOfCandidatesReturned is between 1
         and 100 (default is 10). Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword confidence_threshold: Customized identification confidence threshold, in the range of
         [0, 1]. Advanced user can tweak this value to override default internal threshold for better
         precision on their scenario data. Note there is no guarantee of this threshold value working on
         other data and after algorithm updates. Default value is None.
        :paramtype confidence_threshold: float
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @overload
    def identify_from_person_group(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @distributed_trace
    def identify_from_person_group(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_ids: List[str] = _Unset,
        person_group_id: str = _Unset,
        max_num_of_candidates_returned: Optional[int] = None,
        confidence_threshold: Optional[float] = None,
        **kwargs: Any,
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_ids: Array of query faces faceIds, created by the Face - Detect. Each of the
         faces are identified independently. The valid number of faceIds is between [1, 10]. Required.
        :paramtype face_ids: list[str]
        :keyword person_group_id: Id of the target person group, created by PersonGroup - Create.
         Required.
        :paramtype person_group_id: str
        :keyword max_num_of_candidates_returned: The range of maxNumOfCandidatesReturned is between 1
         and 100 (default is 10). Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword confidence_threshold: Customized identification confidence threshold, in the range of
         [0, 1]. Advanced user can tweak this value to override default internal threshold for better
         precision on their scenario data. Note there is no guarantee of this threshold value working on
         other data and after algorithm updates. Default value is None.
        :paramtype confidence_threshold: float
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"  # Array of query faces faceIds, created by the Face - Detect.
                          Each of the faces are identified independently. The valid number of faceIds
                          is between [1, 10]. Required.
                    ],
                    "personGroupId": "str",  # Id of the target person group, created by
                      PersonGroup - Create. Required.
                    "confidenceThreshold": 0.0,  # Optional. Customized identification confidence
                      threshold, in the range of [0, 1]. Advanced user can tweak this value to override
                      default internal threshold for better precision on their scenario data. Note
                      there is no guarantee of this threshold value working on other data and after
                      algorithm updates.
                    "maxNumOfCandidatesReturned": 0  # Optional. The range of
                      maxNumOfCandidatesReturned is between 1 and 100 (default is 10).
                }

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.IdentifyResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_ids is _Unset:
                raise TypeError("missing required argument: face_ids")
            if person_group_id is _Unset:
                raise TypeError("missing required argument: person_group_id")
            body = {
                "confidencethreshold": confidence_threshold,
                "faceids": face_ids,
                "maxnumofcandidatesreturned": max_num_of_candidates_returned,
                "persongroupid": person_group_id,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_identify_from_person_group_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.IdentifyResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def verify_from_person_group(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "personGroupId": "str",  # Id of the target person group, created by
                      PersonGroup - Create. Required.
                    "personId": "str"  # Specify a certain person in person group. Required.
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @overload
    def verify_from_person_group(
        self,
        *,
        face_id: str,
        person_group_id: str,
        person_id: str,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword person_group_id: Id of the target person group, created by PersonGroup - Create.
         Required.
        :paramtype person_group_id: str
        :keyword person_id: Specify a certain person in person group. Required.
        :paramtype person_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @overload
    def verify_from_person_group(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @distributed_trace
    def verify_from_person_group(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_id: str = _Unset,
        person_group_id: str = _Unset,
        person_id: str = _Unset,
        **kwargs: Any,
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword person_group_id: Id of the target person group, created by PersonGroup - Create.
         Required.
        :paramtype person_group_id: str
        :keyword person_id: Specify a certain person in person group. Required.
        :paramtype person_id: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "personGroupId": "str",  # Id of the target person group, created by
                      PersonGroup - Create. Required.
                    "personId": "str"  # Specify a certain person in person group. Required.
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VerifyResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_id is _Unset:
                raise TypeError("missing required argument: face_id")
            if person_group_id is _Unset:
                raise TypeError("missing required argument: person_group_id")
            if person_id is _Unset:
                raise TypeError("missing required argument: person_id")
            body = {"faceid": face_id, "persongroupid": person_group_id, "personid": person_id}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_verify_from_person_group_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VerifyResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _train_group_initial(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_groups_train_group_request(
            person_group_id=person_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def begin_train_group(self, person_group_id: str, **kwargs: Any) -> LROPoller[_models.TrainingStatus]:
        # pylint: disable=line-too-long
        """Resource action operation template.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :return: An instance of LROPoller that returns TrainingStatus. The TrainingStatus is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.TrainingStatus]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the created time of the person group, large person group or
                      large face list. Required.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the last modify time of the person group, large person
                      group or large face list, could be null value when the group is not successfully
                      trained. Required.
                    "lastSuccessfulTrainingDateTime": "2020-02-20 00:00:00",  # A combined UTC
                      date and time string that describes the last successful training time of the
                      person group, large person group or large face list. Required.
                    "status": "str",  # Training status of the container. Required. Known values
                      are: "nonstarted", "running", "succeeded", and "failed".
                    "message": "str"  # Optional. Show failure message when training failed
                      (omitted when training succeed).
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrainingStatus] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._train_group_initial(  # type: ignore
                person_group_id=person_group_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.TrainingStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.TrainingStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.TrainingStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def get_training_status(self, person_group_id: str, **kwargs: Any) -> _models.TrainingStatus:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :return: TrainingStatus. The TrainingStatus is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.TrainingStatus
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the created time of the person group, large person group or
                      large face list. Required.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the last modify time of the person group, large person
                      group or large face list, could be null value when the group is not successfully
                      trained. Required.
                    "lastSuccessfulTrainingDateTime": "2020-02-20 00:00:00",  # A combined UTC
                      date and time string that describes the last successful training time of the
                      person group, large person group or large face list. Required.
                    "status": "str",  # Training status of the container. Required. Known values
                      are: "nonstarted", "running", "succeeded", and "failed".
                    "message": "str"  # Optional. Show failure message when training failed
                      (omitted when training succeed).
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrainingStatus] = kwargs.pop("cls", None)

        _request = build_person_groups_get_training_status_request(
            person_group_id=person_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TrainingStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class LargePersonGroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.face.FaceClient`'s
        :attr:`large_person_groups` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create_group(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        resource: _models.LargePersonGroup,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.LargePersonGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "largePersonGroupId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def create_group(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_group(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_group(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, resource: Union[_models.LargePersonGroup, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Is one of the following types: LargePersonGroup, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.LargePersonGroup or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "largePersonGroupId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_create_group_request(
            large_person_group_id=large_person_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete_group(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_person_groups_delete_group_request(
            large_person_group_id=large_person_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_group(
        self, large_person_group_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
    ) -> _models.LargePersonGroup:
        # pylint: disable=line-too-long
        """Resource read operation template.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: LargePersonGroup. The LargePersonGroup is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.LargePersonGroup
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "largePersonGroupId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargePersonGroup] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_group_request(
            large_person_group_id=large_person_group_id,
            return_recognition_model=return_recognition_model,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargePersonGroup, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_group(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        resource: _models.LargePersonGroup,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.LargePersonGroup
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "largePersonGroupId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def update_group(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_group(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_group(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, resource: Union[_models.LargePersonGroup, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Is one of the following types: LargePersonGroup, JSON,
         IO[bytes] Required.
        :type resource: ~azure.ai.face.models.LargePersonGroup or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "largePersonGroupId": "str",  # ID of the container. Required.
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "recognitionModel": "str",  # Optional. Name of recognition model.
                      Recognition model is used when the face features are extracted and associated
                      with detected faceIds. The default value is 'recognition_01', if latest model
                      needed, please explicitly specify the model you need. Known values are:
                      "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_update_group_request(
            large_person_group_id=large_person_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_group(
        self,
        *,
        start: Optional[str] = None,
        top: Optional[int] = None,
        return_recognition_model: Optional[bool] = None,
        **kwargs: Any,
    ) -> List[_models.LargePersonGroup]:
        # pylint: disable=line-too-long
        """Operation that lists resources in a paginated way.

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: list of LargePersonGroup
        :rtype: list[~azure.ai.face.models.LargePersonGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "largePersonGroupId": "str",  # ID of the container. Required.
                        "name": "str",  # User defined name, maximum length is 128. Required.
                        "recognitionModel": "str",  # Optional. Name of recognition model.
                          Recognition model is used when the face features are extracted and associated
                          with detected faceIds. The default value is 'recognition_01', if latest model
                          needed, please explicitly specify the model you need. Known values are:
                          "recognition_01", "recognition_02", "recognition_03", and "recognition_04".
                        "userData": "str"  # Optional. Optional user defined data. Length
                          should not exceed 16KB.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LargePersonGroup]] = kwargs.pop("cls", None)

        _request = build_large_person_groups_list_group_request(
            start=start,
            top=top,
            return_recognition_model=return_recognition_model,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LargePersonGroup], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_person(
        self,
        large_person_group_id: str,
        resource: _models.LargePersonGroupPerson,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.LargePersonGroupPerson:
        """Operation that applies to a collection of resources.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.LargePersonGroupPerson
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LargePersonGroupPerson. The LargePersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.LargePersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def create_person(
        self, large_person_group_id: str, resource: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LargePersonGroupPerson:
        """Operation that applies to a collection of resources.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LargePersonGroupPerson. The LargePersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.LargePersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def create_person(
        self, large_person_group_id: str, resource: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LargePersonGroupPerson:
        """Operation that applies to a collection of resources.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LargePersonGroupPerson. The LargePersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.LargePersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @distributed_trace
    def create_person(
        self,
        large_person_group_id: str,
        resource: Union[_models.LargePersonGroupPerson, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> _models.LargePersonGroupPerson:
        """Operation that applies to a collection of resources.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param resource: The resource instance. Is one of the following types: LargePersonGroupPerson,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.face.models.LargePersonGroupPerson or JSON or IO[bytes]
        :return: LargePersonGroupPerson. The LargePersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.LargePersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LargePersonGroupPerson] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_create_person_request(
            large_person_group_id=large_person_group_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargePersonGroupPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_person(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, person_id: str, **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_person_groups_delete_person_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_person(self, large_person_group_id: str, person_id: str, **kwargs: Any) -> _models.LargePersonGroupPerson:
        """Resource read operation template.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :return: LargePersonGroupPerson. The LargePersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.LargePersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargePersonGroupPerson] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_person_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargePersonGroupPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        resource: _models.LargePersonGroupPerson,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.LargePersonGroupPerson
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        resource: Union[_models.LargePersonGroupPerson, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param resource: The resource instance. Is one of the following types: LargePersonGroupPerson,
         JSON, IO[bytes] Required.
        :type resource: ~azure.ai.face.models.LargePersonGroupPerson or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "name": "str",  # User defined name, maximum length is 128. Required.
                    "personId": "str",  # ID of the person. Required.
                    "persistedFaceIds": [
                        "str"  # Optional. Face ids of registered faces in the person.
                    ],
                    "userData": "str"  # Optional. Optional user defined data. Length should not
                      exceed 16KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_update_person_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_person(
        self, large_person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LargePersonGroupPerson]:
        """Operation that lists resources in a paginated way.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LargePersonGroupPerson
        :rtype: list[~azure.ai.face.models.LargePersonGroupPerson]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "name": "str",  # User defined name, maximum length is 128. Required.
                        "personId": "str",  # ID of the person. Required.
                        "persistedFaceIds": [
                            "str"  # Optional. Face ids of registered faces in the
                              person.
                        ],
                        "userData": "str"  # Optional. Optional user defined data. Length
                          should not exceed 16KB.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LargePersonGroupPerson]] = kwargs.pop("cls", None)

        _request = build_large_person_groups_list_person_request(
            large_person_group_id=large_person_group_id,
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LargePersonGroupPerson], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def add_face_from_url(
        self,
        large_person_group_id: str,
        person_id: str,
        body: _models.AddFaceFromUrlContent,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def add_face_from_url(
        self,
        large_person_group_id: str,
        person_id: str,
        body: JSON,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: JSON
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @overload
    def add_face_from_url(
        self,
        large_person_group_id: str,
        person_id: str,
        body: IO[bytes],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """

    @distributed_trace
    def add_face_from_url(
        self,
        large_person_group_id: str,
        person_id: str,
        body: Union[_models.AddFaceFromUrlContent, JSON, IO[bytes]],
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Is one of the following types: AddFaceFromUrlContent, JSON, IO[bytes] Required.
        :type body: ~azure.ai.face.models.AddFaceFromUrlContent or JSON or IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_add_face_from_url_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def add_face_from_stream(
        self,
        large_person_group_id: str,
        person_id: str,
        image_content: bytes,
        *,
        target_face: Optional[str] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Operation that applies to a collection of resources.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1KB. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"  # The persisted face id. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_large_person_groups_add_face_from_stream_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_face(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_person_groups_delete_face_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_face(
        self, large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
    ) -> _models.LargePersonGroupPersonFace:
        """Resource read operation template.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: LargePersonGroupPersonFace. The LargePersonGroupPersonFace is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LargePersonGroupPersonFace
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargePersonGroupPersonFace] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_face_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargePersonGroupPersonFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        resource: _models.LargePersonGroupPersonFace,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: ~azure.ai.face.models.LargePersonGroupPersonFace
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        resource: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        resource: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Required.
        :type resource: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        resource: Union[_models.LargePersonGroupPersonFace, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> None:
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param resource: The resource instance. Is one of the following types:
         LargePersonGroupPersonFace, JSON, IO[bytes] Required.
        :type resource: ~azure.ai.face.models.LargePersonGroupPersonFace or JSON or IO[bytes]
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                resource = {
                    "persistedFaceId": "str",  # Face ID of the face. Required.
                    "userData": "str"  # Optional. User-provided data attached to the face. The
                      size limit is 1KB.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(resource, (IOBase, bytes)):
            _content = resource
        else:
            _content = json.dumps(resource, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_update_face_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    def identify_from_large_person_group(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"  # Array of query faces faceIds, created by the Face - Detect.
                          Each of the faces are identified independently. The valid number of faceIds
                          is between [1, 10]. Required.
                    ],
                    "largePersonGroupId": "str",  # Id of the target large person group, created
                      by LargePersonGroup - Create. Required.
                    "confidenceThreshold": 0.0,  # Optional. Customized identification confidence
                      threshold, in the range of [0, 1]. Advanced user can tweak this value to override
                      default internal threshold for better precision on their scenario data. Note
                      there is no guarantee of this threshold value working on other data and after
                      algorithm updates.
                    "maxNumOfCandidatesReturned": 0  # Optional. The range of
                      maxNumOfCandidatesReturned is between 1 and 100 (default is 10).
                }

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @overload
    def identify_from_large_person_group(
        self,
        *,
        face_ids: List[str],
        large_person_group_id: str,
        content_type: str = "application/json",
        max_num_of_candidates_returned: Optional[int] = None,
        confidence_threshold: Optional[float] = None,
        **kwargs: Any,
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :keyword face_ids: Array of query faces faceIds, created by the Face - Detect. Each of the
         faces are identified independently. The valid number of faceIds is between [1, 10]. Required.
        :paramtype face_ids: list[str]
        :keyword large_person_group_id: Id of the target large person group, created by
         LargePersonGroup - Create. Required.
        :paramtype large_person_group_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_num_of_candidates_returned: The range of maxNumOfCandidatesReturned is between 1
         and 100 (default is 10). Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword confidence_threshold: Customized identification confidence threshold, in the range of
         [0, 1]. Advanced user can tweak this value to override default internal threshold for better
         precision on their scenario data. Note there is no guarantee of this threshold value working on
         other data and after algorithm updates. Default value is None.
        :paramtype confidence_threshold: float
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @overload
    def identify_from_large_person_group(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """

    @distributed_trace
    def identify_from_large_person_group(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_ids: List[str] = _Unset,
        large_person_group_id: str = _Unset,
        max_num_of_candidates_returned: Optional[int] = None,
        confidence_threshold: Optional[float] = None,
        **kwargs: Any,
    ) -> List[_models.IdentifyResult]:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_ids: Array of query faces faceIds, created by the Face - Detect. Each of the
         faces are identified independently. The valid number of faceIds is between [1, 10]. Required.
        :paramtype face_ids: list[str]
        :keyword large_person_group_id: Id of the target large person group, created by
         LargePersonGroup - Create. Required.
        :paramtype large_person_group_id: str
        :keyword max_num_of_candidates_returned: The range of maxNumOfCandidatesReturned is between 1
         and 100 (default is 10). Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword confidence_threshold: Customized identification confidence threshold, in the range of
         [0, 1]. Advanced user can tweak this value to override default internal threshold for better
         precision on their scenario data. Note there is no guarantee of this threshold value working on
         other data and after algorithm updates. Default value is None.
        :paramtype confidence_threshold: float
        :return: list of IdentifyResult
        :rtype: list[~azure.ai.face.models.IdentifyResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"  # Array of query faces faceIds, created by the Face - Detect.
                          Each of the faces are identified independently. The valid number of faceIds
                          is between [1, 10]. Required.
                    ],
                    "largePersonGroupId": "str",  # Id of the target large person group, created
                      by LargePersonGroup - Create. Required.
                    "confidenceThreshold": 0.0,  # Optional. Customized identification confidence
                      threshold, in the range of [0, 1]. Advanced user can tweak this value to override
                      default internal threshold for better precision on their scenario data. Note
                      there is no guarantee of this threshold value working on other data and after
                      algorithm updates.
                    "maxNumOfCandidatesReturned": 0  # Optional. The range of
                      maxNumOfCandidatesReturned is between 1 and 100 (default is 10).
                }

                # response body for status code(s): 200
                response == [
                    {
                        "candidates": [
                            {
                                "confidence": 0.0,  # Confidence value of the
                                  candidate. The higher confidence, the more similar. Range between
                                  [0,1]. Required.
                                "personId": "str"  # PersonId of the candidate.
                                  Required.
                            }
                        ],
                        "faceId": "str"  # Face ID of the query face. Required.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.IdentifyResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_ids is _Unset:
                raise TypeError("missing required argument: face_ids")
            if large_person_group_id is _Unset:
                raise TypeError("missing required argument: large_person_group_id")
            body = {
                "confidencethreshold": confidence_threshold,
                "faceids": face_ids,
                "largepersongroupid": large_person_group_id,
                "maxnumofcandidatesreturned": max_num_of_candidates_returned,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_identify_from_large_person_group_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.IdentifyResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def verify_from_large_person_group(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "largePersonGroupId": "str",  # Id of the target large person group, created
                      by LargePersonGroup - Create. Required.
                    "personId": "str"  # Specify a certain person in large person group.
                      Required.
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @overload
    def verify_from_large_person_group(
        self,
        *,
        face_id: str,
        large_person_group_id: str,
        person_id: str,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword large_person_group_id: Id of the target large person group, created by
         LargePersonGroup - Create. Required.
        :paramtype large_person_group_id: str
        :keyword person_id: Specify a certain person in large person group. Required.
        :paramtype person_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @overload
    def verify_from_large_person_group(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @distributed_trace
    def verify_from_large_person_group(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_id: str = _Unset,
        large_person_group_id: str = _Unset,
        person_id: str = _Unset,
        **kwargs: Any,
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """A remote procedure call (RPC) operation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword large_person_group_id: Id of the target large person group, created by
         LargePersonGroup - Create. Required.
        :paramtype large_person_group_id: str
        :keyword person_id: Specify a certain person in large person group. Required.
        :paramtype person_id: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "largePersonGroupId": "str",  # Id of the target large person group, created
                      by LargePersonGroup - Create. Required.
                    "personId": "str"  # Specify a certain person in large person group.
                      Required.
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VerifyResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_id is _Unset:
                raise TypeError("missing required argument: face_id")
            if large_person_group_id is _Unset:
                raise TypeError("missing required argument: large_person_group_id")
            if person_id is _Unset:
                raise TypeError("missing required argument: person_id")
            body = {"faceid": face_id, "largepersongroupid": large_person_group_id, "personid": person_id}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_verify_from_large_person_group_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VerifyResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _train_group_initial(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, **kwargs: Any
    ) -> None:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_person_groups_train_group_request(
            large_person_group_id=large_person_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def begin_train_group(self, large_person_group_id: str, **kwargs: Any) -> LROPoller[_models.TrainingStatus]:
        # pylint: disable=line-too-long
        """Resource action operation template.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :return: An instance of LROPoller that returns TrainingStatus. The TrainingStatus is compatible
         with MutableMapping
        :rtype: ~azure.core.polling.LROPoller[~azure.ai.face.models.TrainingStatus]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the created time of the person group, large person group or
                      large face list. Required.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the last modify time of the person group, large person
                      group or large face list, could be null value when the group is not successfully
                      trained. Required.
                    "lastSuccessfulTrainingDateTime": "2020-02-20 00:00:00",  # A combined UTC
                      date and time string that describes the last successful training time of the
                      person group, large person group or large face list. Required.
                    "status": "str",  # Training status of the container. Required. Known values
                      are: "nonstarted", "running", "succeeded", and "failed".
                    "message": "str"  # Optional. Show failure message when training failed
                      (omitted when training succeed).
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrainingStatus] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._train_group_initial(  # type: ignore
                large_person_group_id=large_person_group_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.TrainingStatus, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.TrainingStatus].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.TrainingStatus](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @distributed_trace
    def get_training_status(self, large_person_group_id: str, **kwargs: Any) -> _models.TrainingStatus:
        # pylint: disable=line-too-long
        """The most basic operation that applies to a resource.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :return: TrainingStatus. The TrainingStatus is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.TrainingStatus
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the created time of the person group, large person group or
                      large face list. Required.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # A combined UTC date and time
                      string that describes the last modify time of the person group, large person
                      group or large face list, could be null value when the group is not successfully
                      trained. Required.
                    "lastSuccessfulTrainingDateTime": "2020-02-20 00:00:00",  # A combined UTC
                      date and time string that describes the last successful training time of the
                      person group, large person group or large face list. Required.
                    "status": "str",  # Training status of the container. Required. Known values
                      are: "nonstarted", "running", "succeeded", and "failed".
                    "message": "str"  # Optional. Show failure message when training failed
                      (omitted when training succeed).
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrainingStatus] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_training_status_request(
            large_person_group_id=large_person_group_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TrainingStatus, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class LivenessSessionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.face.FaceClient`'s
        :attr:`liveness_sessions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_sessions(
        self, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LivenessSessionItem]:
        """Lists all matching session types.
        List sessions from the last sessionId greater than the "start".
        The result should be ordered by sessionId in ascending order.

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LivenessSessionItem
        :rtype: list[~azure.ai.face.models.LivenessSessionItem]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "createdDateTime": "2020-02-20 00:00:00",  # Session creation time in
                          millisecond from epoch. Required.
                        "deviceCorrelationId": "str",  # Device Correlation Id to use for
                          linking multiple sessions together. Required.
                        "id": "str",  # Unique ID to reference this session. Required.
                        "sessionExpired": bool,  # Whether or not the session is expired.
                          Required.
                        "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in
                          seconds. Range is 60 to 86400 seconds.
                        "sessionStartDateTime": "2020-02-20 00:00:00"  # Optional. Session
                          started time from session auth token.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LivenessSessionItem]] = kwargs.pop("cls", None)

        _request = build_liveness_sessions_list_sessions_request(
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LivenessSessionItem], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_session(self, session_id: str, **kwargs: Any) -> _models.LivenessSession:
        """Get session result of detectLiveness.

        :param session_id: Unique ID to reference this session. Required.
        :type session_id: str
        :return: LivenessSession. The LivenessSession is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSession
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Session creation time in
                      millisecond from epoch. Required.
                    "deviceCorrelationId": "str",  # Device Correlation Id to use for linking
                      multiple sessions together. Required.
                    "id": "str",  # Unique ID to reference this session. Required.
                    "sessionExpired": bool,  # Whether or not the session is expired. Required.
                    "status": "str",  # The session status. Required. Known values are:
                      "NotStarted", "Started", and "ResultAvailable".
                    "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in seconds.
                      Range is 60 to 86400 seconds.
                    "result": {
                        "clientRequestId": "str",  # Client request ID in the request header.
                          Required.
                        "digest": "str",  # The digest of the request body. Required.
                        "id": 0,  # ID of this audit entry. Required.
                        "receivedDateTime": "2020-02-20 00:00:00",  # The UTC date time of
                          the request. Required.
                        "request": {
                            "contentType": "str",  # The content type of the request.
                              Required.
                            "method": "str",  # The HTTP method of the request. Required.
                            "url": "str",  # The URL of the request. Required.
                            "contentLength": 0,  # Optional. The length of the request
                              body in bytes.
                            "userAgent": "str"  # Optional. The user agent of the
                              request.
                        },
                        "requestId": "str",  # Request ID in the request header. Required.
                        "response": {
                            "body": {
                                "str": {}  # The response body. Required.
                            },
                            "latencyInMilliseconds": 0,  # The latency of the request.
                              Required.
                            "statusCode": 0  # The HTTP status code of the request.
                              Required.
                        },
                        "sessionId": "str"  # Session ID of this audit entry. Required.
                    },
                    "sessionStartDateTime": "2020-02-20 00:00:00"  # Optional. Session started
                      time from session auth token.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LivenessSession] = kwargs.pop("cls", None)

        _request = build_liveness_sessions_get_session_request(
            session_id=session_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LivenessSession, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_session(self, session_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a session and all of it's audit results.

        :param session_id: Unique ID to reference this session. Required.
        :type session_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_liveness_sessions_delete_session_request(
            session_id=session_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_session_audit_entries(
        self, session_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LivenessSessionAuditEntry]:
        """Get session audit requests/responses for the session.

        :param session_id: Unique ID to reference this session. Required.
        :type session_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LivenessSessionAuditEntry
        :rtype: list[~azure.ai.face.models.LivenessSessionAuditEntry]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "clientRequestId": "str",  # Client request ID in the request header.
                          Required.
                        "digest": "str",  # The digest of the request body. Required.
                        "id": 0,  # ID of this audit entry. Required.
                        "receivedDateTime": "2020-02-20 00:00:00",  # The UTC date time of
                          the request. Required.
                        "request": {
                            "contentType": "str",  # The content type of the request.
                              Required.
                            "method": "str",  # The HTTP method of the request. Required.
                            "url": "str",  # The URL of the request. Required.
                            "contentLength": 0,  # Optional. The length of the request
                              body in bytes.
                            "userAgent": "str"  # Optional. The user agent of the
                              request.
                        },
                        "requestId": "str",  # Request ID in the request header. Required.
                        "response": {
                            "body": {
                                "str": {}  # The response body. Required.
                            },
                            "latencyInMilliseconds": 0,  # The latency of the request.
                              Required.
                            "statusCode": 0  # The HTTP status code of the request.
                              Required.
                        },
                        "sessionId": "str"  # Session ID of this audit entry. Required.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LivenessSessionAuditEntry]] = kwargs.pop("cls", None)

        _request = build_liveness_sessions_list_session_audit_entries_request(
            session_id=session_id,
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LivenessSessionAuditEntry], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_session(
        self, body: _models.LivenessSessionCreationContent, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        """Creates face liveness detection session.

        :param body: Required.
        :type body: ~azure.ai.face.models.LivenessSessionCreationContent
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "deviceCorrelationId": "str",  # Device Correlation Id to use for linking
                      multiple sessions together. Required.
                    "livenessOperationMode": "str",  # The operation mode for the liveness modal.
                      Required.
                    "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in seconds.
                      Range is 60 to 86400 seconds.
                    "deviceCorrelationIdSetInClient": bool,  # Optional. Whether or not the
                      device correlation id is set by the client.
                    "sendResultsToClient": bool  # Optional. Whether or not send back the
                      operation response to client.
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """

    @overload
    def create_session(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        """Creates face liveness detection session.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """

    @overload
    def create_session(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        """Creates face liveness detection session.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """

    @distributed_trace
    def create_session(
        self, body: Union[_models.LivenessSessionCreationContent, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        """Creates face liveness detection session.

        :param body: Is one of the following types: LivenessSessionCreationContent, JSON, IO[bytes]
         Required.
        :type body: ~azure.ai.face.models.LivenessSessionCreationContent or JSON or IO[bytes]
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "deviceCorrelationId": "str",  # Device Correlation Id to use for linking
                      multiple sessions together. Required.
                    "livenessOperationMode": "str",  # The operation mode for the liveness modal.
                      Required.
                    "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in seconds.
                      Range is 60 to 86400 seconds.
                    "deviceCorrelationIdSetInClient": bool,  # Optional. Whether or not the
                      device correlation id is set by the client.
                    "sendResultsToClient": bool  # Optional. Whether or not send back the
                      operation response to client.
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LivenessSessionCreationResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_liveness_sessions_create_session_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LivenessSessionCreationResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class LivenessWithVerifySessionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.face.FaceClient`'s
        :attr:`liveness_with_verify_sessions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_sessions(
        self, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LivenessSessionItem]:
        """Lists all matching session types.
        List sessions from the last sessionId greater than the "start".
        The result should be ordered by sessionId in ascending order.

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LivenessSessionItem
        :rtype: list[~azure.ai.face.models.LivenessSessionItem]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "createdDateTime": "2020-02-20 00:00:00",  # Session creation time in
                          millisecond from epoch. Required.
                        "deviceCorrelationId": "str",  # Device Correlation Id to use for
                          linking multiple sessions together. Required.
                        "id": "str",  # Unique ID to reference this session. Required.
                        "sessionExpired": bool,  # Whether or not the session is expired.
                          Required.
                        "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in
                          seconds. Range is 60 to 86400 seconds.
                        "sessionStartDateTime": "2020-02-20 00:00:00"  # Optional. Session
                          started time from session auth token.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LivenessSessionItem]] = kwargs.pop("cls", None)

        _request = build_liveness_with_verify_sessions_list_sessions_request(
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LivenessSessionItem], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_session(self, session_id: str, **kwargs: Any) -> _models.LivenessWithVerifySession:
        """Get session result of detectLiveness.

        :param session_id: Unique ID to reference this session. Required.
        :type session_id: str
        :return: LivenessWithVerifySession. The LivenessWithVerifySession is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessWithVerifySession
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",  # Session creation time in
                      millisecond from epoch. Required.
                    "deviceCorrelationId": "str",  # Device Correlation Id to use for linking
                      multiple sessions together. Required.
                    "id": "str",  # Unique ID to reference this session. Required.
                    "sessionExpired": bool,  # Whether or not the session is expired. Required.
                    "status": "str",  # The session status. Required. Known values are:
                      "NotStarted", "Started", and "ResultAvailable".
                    "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in seconds.
                      Range is 60 to 86400 seconds.
                    "result": {
                        "clientRequestId": "str",  # Client request ID in the request header.
                          Required.
                        "digest": "str",  # The digest of the request body. Required.
                        "id": 0,  # ID of this audit entry. Required.
                        "receivedDateTime": "2020-02-20 00:00:00",  # The UTC date time of
                          the request. Required.
                        "request": {
                            "contentType": "str",  # The content type of the request.
                              Required.
                            "method": "str",  # The HTTP method of the request. Required.
                            "url": "str",  # The URL of the request. Required.
                            "contentLength": 0,  # Optional. The length of the request
                              body in bytes.
                            "userAgent": "str"  # Optional. The user agent of the
                              request.
                        },
                        "requestId": "str",  # Request ID in the request header. Required.
                        "response": {
                            "body": {
                                "str": {}  # The response body. Required.
                            },
                            "latencyInMilliseconds": 0,  # The latency of the request.
                              Required.
                            "statusCode": 0  # The HTTP status code of the request.
                              Required.
                        },
                        "sessionId": "str"  # Session ID of this audit entry. Required.
                    },
                    "sessionStartDateTime": "2020-02-20 00:00:00"  # Optional. Session started
                      time from session auth token.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LivenessWithVerifySession] = kwargs.pop("cls", None)

        _request = build_liveness_with_verify_sessions_get_session_request(
            session_id=session_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LivenessWithVerifySession, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_session(self, session_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a session and all of it's audit results.

        :param session_id: Unique ID to reference this session. Required.
        :type session_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_liveness_with_verify_sessions_delete_session_request(
            session_id=session_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_session_audit_entries(
        self, session_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LivenessWithVerifySessionAuditEntry]:
        """Get session audit requests/responses for the session.

        :param session_id: Unique ID to reference this session. Required.
        :type session_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LivenessWithVerifySessionAuditEntry
        :rtype: list[~azure.ai.face.models.LivenessWithVerifySessionAuditEntry]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "clientRequestId": "str",  # Client request ID in the request header.
                          Required.
                        "digest": "str",  # The digest of the request body. Required.
                        "id": 0,  # ID of this audit entry. Required.
                        "receivedDateTime": "2020-02-20 00:00:00",  # The UTC date time of
                          the request. Required.
                        "request": {
                            "contentType": "str",  # The content type of the request.
                              Required.
                            "method": "str",  # The HTTP method of the request. Required.
                            "url": "str",  # The URL of the request. Required.
                            "contentLength": 0,  # Optional. The length of the request
                              body in bytes.
                            "userAgent": "str"  # Optional. The user agent of the
                              request.
                        },
                        "requestId": "str",  # Request ID in the request header. Required.
                        "response": {
                            "body": {
                                "str": {}  # The response body. Required.
                            },
                            "latencyInMilliseconds": 0,  # The latency of the request.
                              Required.
                            "statusCode": 0  # The HTTP status code of the request.
                              Required.
                        },
                        "sessionId": "str"  # Session ID of this audit entry. Required.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LivenessWithVerifySessionAuditEntry]] = kwargs.pop("cls", None)

        _request = build_liveness_with_verify_sessions_list_session_audit_entries_request(
            session_id=session_id,
            start=start,
            top=top,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LivenessWithVerifySessionAuditEntry], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_session(
        self, body: _models.LivenessSessionCreationContent, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        """Creates face liveness detection session.

        :param body: Required.
        :type body: ~azure.ai.face.models.LivenessSessionCreationContent
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "deviceCorrelationId": "str",  # Device Correlation Id to use for linking
                      multiple sessions together. Required.
                    "livenessOperationMode": "str",  # The operation mode for the liveness modal.
                      Required.
                    "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in seconds.
                      Range is 60 to 86400 seconds.
                    "deviceCorrelationIdSetInClient": bool,  # Optional. Whether or not the
                      device correlation id is set by the client.
                    "sendResultsToClient": bool  # Optional. Whether or not send back the
                      operation response to client.
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """

    @overload
    def create_session(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        """Creates face liveness detection session.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """

    @overload
    def create_session(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        """Creates face liveness detection session.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """

    @distributed_trace
    def create_session(
        self, body: Union[_models.LivenessSessionCreationContent, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        """Creates face liveness detection session.

        :param body: Is one of the following types: LivenessSessionCreationContent, JSON, IO[bytes]
         Required.
        :type body: ~azure.ai.face.models.LivenessSessionCreationContent or JSON or IO[bytes]
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "deviceCorrelationId": "str",  # Device Correlation Id to use for linking
                      multiple sessions together. Required.
                    "livenessOperationMode": "str",  # The operation mode for the liveness modal.
                      Required.
                    "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in seconds.
                      Range is 60 to 86400 seconds.
                    "deviceCorrelationIdSetInClient": bool,  # Optional. Whether or not the
                      device correlation id is set by the client.
                    "sendResultsToClient": bool  # Optional. Whether or not send back the
                      operation response to client.
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.LivenessSessionCreationResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_liveness_with_verify_sessions_create_session_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LivenessSessionCreationResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_session_with_verify_image(
        self, body: _models.LivenessSessionWithVerifyImageCreationContent, **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        # pylint: disable=line-too-long
        """Creates face liveness detection session with verify image.

        :param body: Required.
        :type body: ~azure.ai.face.models.LivenessSessionWithVerifyImageCreationContent
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "CreationContent": {
                        "deviceCorrelationId": "str",  # Device Correlation Id to use for
                          linking multiple sessions together. Required.
                        "livenessOperationMode": "str",  # The operation mode for the
                          liveness modal. Required.
                        "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in
                          seconds. Range is 60 to 86400 seconds.
                        "deviceCorrelationIdSetInClient": bool,  # Optional. Whether or not
                          the device correlation id is set by the client.
                        "sendResultsToClient": bool  # Optional. Whether or not send back the
                          operation response to client.
                    },
                    "VerifyImage": filetype
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """

    @overload
    def create_session_with_verify_image(self, body: JSON, **kwargs: Any) -> _models.LivenessSessionCreationResult:
        """Creates face liveness detection session with verify image.

        :param body: Required.
        :type body: JSON
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """

    @distributed_trace
    def create_session_with_verify_image(
        self, body: Union[_models.LivenessSessionWithVerifyImageCreationContent, JSON], **kwargs: Any
    ) -> _models.LivenessSessionCreationResult:
        # pylint: disable=line-too-long
        """Creates face liveness detection session with verify image.

        :param body: Is either a LivenessSessionWithVerifyImageCreationContent type or a JSON type.
         Required.
        :type body: ~azure.ai.face.models.LivenessSessionWithVerifyImageCreationContent or JSON
        :return: LivenessSessionCreationResult. The LivenessSessionCreationResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.face.models.LivenessSessionCreationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "CreationContent": {
                        "deviceCorrelationId": "str",  # Device Correlation Id to use for
                          linking multiple sessions together. Required.
                        "livenessOperationMode": "str",  # The operation mode for the
                          liveness modal. Required.
                        "authTokenTimeToLiveInSeconds": 0,  # Optional. Session length in
                          seconds. Range is 60 to 86400 seconds.
                        "deviceCorrelationIdSetInClient": bool,  # Optional. Whether or not
                          the device correlation id is set by the client.
                        "sendResultsToClient": bool  # Optional. Whether or not send back the
                          operation response to client.
                    },
                    "VerifyImage": filetype
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",  # Authorization token for use by the client application.
                      Required.
                    "sessionId": "str"  # Unique ID to reference this session. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LivenessSessionCreationResult] = kwargs.pop("cls", None)

        _body = body.as_dict() if isinstance(body, _model_base.Model) else body
        _file_fields: List[str] = ["VerifyImage"]
        _data_fields: List[str] = ["CreationContent"]
        _files, _data = prepare_multipart_form_data(_body, _file_fields, _data_fields)

        _request = build_liveness_with_verify_sessions_create_session_with_verify_image_request(
            api_version=self._config.api_version,
            files=_files,
            data=_data,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LivenessSessionCreationResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class FaceClientOperationsMixin(FaceClientMixinABC):
    @overload
    def detect_from_url(
        self,
        body: JSON,
        *,
        return_face_id: Optional[bool] = None,
        return_face_landmarks: Optional[bool] = None,
        return_face_attributes: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.RecognitionModel]] = None,
        return_recognition_model: Optional[bool] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        face_id_time_to_live: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]:
        # pylint: disable=line-too-long
        """Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks,
        and attributes.

        :param body: Required.
        :type body: JSON
        :keyword return_face_id: Return faceIds of the detected faces or not. The default value is
         true. Default value is None.
        :paramtype return_face_id: bool
        :keyword return_face_landmarks: Return face landmarks of the detected faces or not. The default
         value is false. Default value is None.
        :paramtype return_face_landmarks: bool
        :keyword return_face_attributes: Analyze and return the one or more specified face attributes
         in the comma-separated string like 'returnFaceAttributes=headPose,glasses'. Supported face
         attributes include headPose, glasses, occlusion, accessories, blur, exposure, noise, mask, and
         qualityForRecognition. Face attribute analysis has additional computational and time cost.
         Default value is None.
        :paramtype return_face_attributes: str
        :keyword recognition_model: The 'recognitionModel' associated with the detected faceIds. Known
         values are: "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default
         value is None.
        :paramtype recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Known
         values are: "detection_01", "detection_02", and "detection_03". Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword face_id_time_to_live: The number of seconds for the face ID being cached. Supported
         range from 60 seconds up to 86400 seconds. The default value is 86400 (24 hours). Default value
         is None.
        :paramtype face_id_time_to_live: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FaceDetectionResult
        :rtype: list[~azure.ai.face.models.FaceDetectionResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == [
                    {
                        "faceId": "str",  # Unique faceId of the detected face, created by
                          detection API and it will expire 24 hours after the detection call. Required.
                        "faceAttributes": {
                            "accessories": [
                                {
                                    "confidence": 0.0,  # Confidence level of the
                                      accessory type. Range between [0,1]. Required.
                                    "type": "str"  # Type of the accessory.
                                      Required. Known values are: "headwear", "glasses", and "mask".
                                }
                            ],
                            "age": 0,  # Optional. Age in years.
                            "blur": {
                                "blurLevel": "str",  # An enum value indicating level
                                  of blurriness. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of
                                  blurriness ranging from 0 to 1. Required.
                            },
                            "exposure": {
                                "exposureLevel": "str",  # An enum value indicating
                                  level of exposure. Required. Known values are: "underExposure",
                                  "goodExposure", and "overExposure".
                                "value": 0.0  # A number indicating level of exposure
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. Required.
                            },
                            "facialHair": {
                                "beard": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "moustache": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "sideburns": 0.0  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                            },
                            "glasses": "str",  # Optional. Glasses type if any of the
                              face. Known values are: "noGlasses", "readingGlasses", "sunglasses", and
                              "swimmingGoggles".
                            "hair": {
                                "bald": 0.0,  # A number describing confidence level
                                  of whether the person is bald. Required.
                                "hairColor": [
                                    {
                                        "color": "str",  # Name of the hair
                                          color. Required. Known values are: "unknown", "white",
                                          "gray", "blond", "brown", "red", "black", and "other".
                                        "confidence": 0.0  # Confidence level
                                          of the color. Range between [0,1]. Required.
                                    }
                                ],
                                "invisible": bool  # A boolean value describing
                                  whether the hair is visible in the image. Required.
                            },
                            "headPose": {
                                "pitch": 0.0,  # Value of angles. Required.
                                "roll": 0.0,  # Value of angles. Required.
                                "yaw": 0.0  # Value of angles. Required.
                            },
                            "mask": {
                                "noseAndMouthCovered": bool,  # A boolean value
                                  indicating whether nose and mouth are covered. Required.
                                "type": "str"  # Mask type if any of the face.
                                  Required. Known values are: "faceMask", "noMask",
                                  "otherMaskOrOcclusion", and "uncertain".
                            },
                            "noise": {
                                "noiseLevel": "str",  # An enum value indicating
                                  level of noise. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of noise
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. [0, 0.3) is low noise
                                  level. [0.3, 0.7) is medium noise level. [0.7, 1] is high noise
                                  level. Required.
                            },
                            "occlusion": {
                                "eyeOccluded": bool,  # A boolean value indicating
                                  whether eyes are occluded. Required.
                                "foreheadOccluded": bool,  # A boolean value
                                  indicating whether forehead is occluded. Required.
                                "mouthOccluded": bool  # A boolean value indicating
                                  whether the mouth is occluded. Required.
                            },
                            "qualityForRecognition": "str",  # Optional. Properties
                              describing the overall image quality regarding whether the image being
                              used in the detection is of sufficient quality to attempt face
                              recognition on. Known values are: "low", "medium", and "high".
                            "smile": 0.0  # Optional. Smile intensity, a number between
                              [0,1].
                        },
                        "faceLandmarks": {
                            "eyeLeftBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            }
                        },
                        "faceRectangle": {
                            "height": 0,  # The height of the rectangle, in pixels.
                              Required.
                            "left": 0,  # The distance from the left edge if the image to
                              the left edge of the rectangle, in pixels. Required.
                            "top": 0,  # The distance from the top edge if the image to
                              the top edge of the rectangle, in pixels. Required.
                            "width": 0  # The width of the rectangle, in pixels.
                              Required.
                        },
                        "recognitionModel": "str"  # Optional. The 'recognitionModel'
                          associated with this faceId. This is only returned when
                          'returnRecognitionModel' is explicitly set as true.
                    }
                ]
        """

    @overload
    def detect_from_url(
        self,
        *,
        url: str,
        return_face_id: Optional[bool] = None,
        return_face_landmarks: Optional[bool] = None,
        return_face_attributes: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.RecognitionModel]] = None,
        return_recognition_model: Optional[bool] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        face_id_time_to_live: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]:
        # pylint: disable=line-too-long
        """Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks,
        and attributes.

        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword return_face_id: Return faceIds of the detected faces or not. The default value is
         true. Default value is None.
        :paramtype return_face_id: bool
        :keyword return_face_landmarks: Return face landmarks of the detected faces or not. The default
         value is false. Default value is None.
        :paramtype return_face_landmarks: bool
        :keyword return_face_attributes: Analyze and return the one or more specified face attributes
         in the comma-separated string like 'returnFaceAttributes=headPose,glasses'. Supported face
         attributes include headPose, glasses, occlusion, accessories, blur, exposure, noise, mask, and
         qualityForRecognition. Face attribute analysis has additional computational and time cost.
         Default value is None.
        :paramtype return_face_attributes: str
        :keyword recognition_model: The 'recognitionModel' associated with the detected faceIds. Known
         values are: "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default
         value is None.
        :paramtype recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Known
         values are: "detection_01", "detection_02", and "detection_03". Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword face_id_time_to_live: The number of seconds for the face ID being cached. Supported
         range from 60 seconds up to 86400 seconds. The default value is 86400 (24 hours). Default value
         is None.
        :paramtype face_id_time_to_live: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FaceDetectionResult
        :rtype: list[~azure.ai.face.models.FaceDetectionResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "faceId": "str",  # Unique faceId of the detected face, created by
                          detection API and it will expire 24 hours after the detection call. Required.
                        "faceAttributes": {
                            "accessories": [
                                {
                                    "confidence": 0.0,  # Confidence level of the
                                      accessory type. Range between [0,1]. Required.
                                    "type": "str"  # Type of the accessory.
                                      Required. Known values are: "headwear", "glasses", and "mask".
                                }
                            ],
                            "age": 0,  # Optional. Age in years.
                            "blur": {
                                "blurLevel": "str",  # An enum value indicating level
                                  of blurriness. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of
                                  blurriness ranging from 0 to 1. Required.
                            },
                            "exposure": {
                                "exposureLevel": "str",  # An enum value indicating
                                  level of exposure. Required. Known values are: "underExposure",
                                  "goodExposure", and "overExposure".
                                "value": 0.0  # A number indicating level of exposure
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. Required.
                            },
                            "facialHair": {
                                "beard": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "moustache": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "sideburns": 0.0  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                            },
                            "glasses": "str",  # Optional. Glasses type if any of the
                              face. Known values are: "noGlasses", "readingGlasses", "sunglasses", and
                              "swimmingGoggles".
                            "hair": {
                                "bald": 0.0,  # A number describing confidence level
                                  of whether the person is bald. Required.
                                "hairColor": [
                                    {
                                        "color": "str",  # Name of the hair
                                          color. Required. Known values are: "unknown", "white",
                                          "gray", "blond", "brown", "red", "black", and "other".
                                        "confidence": 0.0  # Confidence level
                                          of the color. Range between [0,1]. Required.
                                    }
                                ],
                                "invisible": bool  # A boolean value describing
                                  whether the hair is visible in the image. Required.
                            },
                            "headPose": {
                                "pitch": 0.0,  # Value of angles. Required.
                                "roll": 0.0,  # Value of angles. Required.
                                "yaw": 0.0  # Value of angles. Required.
                            },
                            "mask": {
                                "noseAndMouthCovered": bool,  # A boolean value
                                  indicating whether nose and mouth are covered. Required.
                                "type": "str"  # Mask type if any of the face.
                                  Required. Known values are: "faceMask", "noMask",
                                  "otherMaskOrOcclusion", and "uncertain".
                            },
                            "noise": {
                                "noiseLevel": "str",  # An enum value indicating
                                  level of noise. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of noise
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. [0, 0.3) is low noise
                                  level. [0.3, 0.7) is medium noise level. [0.7, 1] is high noise
                                  level. Required.
                            },
                            "occlusion": {
                                "eyeOccluded": bool,  # A boolean value indicating
                                  whether eyes are occluded. Required.
                                "foreheadOccluded": bool,  # A boolean value
                                  indicating whether forehead is occluded. Required.
                                "mouthOccluded": bool  # A boolean value indicating
                                  whether the mouth is occluded. Required.
                            },
                            "qualityForRecognition": "str",  # Optional. Properties
                              describing the overall image quality regarding whether the image being
                              used in the detection is of sufficient quality to attempt face
                              recognition on. Known values are: "low", "medium", and "high".
                            "smile": 0.0  # Optional. Smile intensity, a number between
                              [0,1].
                        },
                        "faceLandmarks": {
                            "eyeLeftBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            }
                        },
                        "faceRectangle": {
                            "height": 0,  # The height of the rectangle, in pixels.
                              Required.
                            "left": 0,  # The distance from the left edge if the image to
                              the left edge of the rectangle, in pixels. Required.
                            "top": 0,  # The distance from the top edge if the image to
                              the top edge of the rectangle, in pixels. Required.
                            "width": 0  # The width of the rectangle, in pixels.
                              Required.
                        },
                        "recognitionModel": "str"  # Optional. The 'recognitionModel'
                          associated with this faceId. This is only returned when
                          'returnRecognitionModel' is explicitly set as true.
                    }
                ]
        """

    @overload
    def detect_from_url(
        self,
        body: IO[bytes],
        *,
        return_face_id: Optional[bool] = None,
        return_face_landmarks: Optional[bool] = None,
        return_face_attributes: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.RecognitionModel]] = None,
        return_recognition_model: Optional[bool] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        face_id_time_to_live: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]:
        # pylint: disable=line-too-long
        """Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks,
        and attributes.

        :param body: Required.
        :type body: IO[bytes]
        :keyword return_face_id: Return faceIds of the detected faces or not. The default value is
         true. Default value is None.
        :paramtype return_face_id: bool
        :keyword return_face_landmarks: Return face landmarks of the detected faces or not. The default
         value is false. Default value is None.
        :paramtype return_face_landmarks: bool
        :keyword return_face_attributes: Analyze and return the one or more specified face attributes
         in the comma-separated string like 'returnFaceAttributes=headPose,glasses'. Supported face
         attributes include headPose, glasses, occlusion, accessories, blur, exposure, noise, mask, and
         qualityForRecognition. Face attribute analysis has additional computational and time cost.
         Default value is None.
        :paramtype return_face_attributes: str
        :keyword recognition_model: The 'recognitionModel' associated with the detected faceIds. Known
         values are: "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default
         value is None.
        :paramtype recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Known
         values are: "detection_01", "detection_02", and "detection_03". Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword face_id_time_to_live: The number of seconds for the face ID being cached. Supported
         range from 60 seconds up to 86400 seconds. The default value is 86400 (24 hours). Default value
         is None.
        :paramtype face_id_time_to_live: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FaceDetectionResult
        :rtype: list[~azure.ai.face.models.FaceDetectionResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "faceId": "str",  # Unique faceId of the detected face, created by
                          detection API and it will expire 24 hours after the detection call. Required.
                        "faceAttributes": {
                            "accessories": [
                                {
                                    "confidence": 0.0,  # Confidence level of the
                                      accessory type. Range between [0,1]. Required.
                                    "type": "str"  # Type of the accessory.
                                      Required. Known values are: "headwear", "glasses", and "mask".
                                }
                            ],
                            "age": 0,  # Optional. Age in years.
                            "blur": {
                                "blurLevel": "str",  # An enum value indicating level
                                  of blurriness. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of
                                  blurriness ranging from 0 to 1. Required.
                            },
                            "exposure": {
                                "exposureLevel": "str",  # An enum value indicating
                                  level of exposure. Required. Known values are: "underExposure",
                                  "goodExposure", and "overExposure".
                                "value": 0.0  # A number indicating level of exposure
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. Required.
                            },
                            "facialHair": {
                                "beard": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "moustache": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "sideburns": 0.0  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                            },
                            "glasses": "str",  # Optional. Glasses type if any of the
                              face. Known values are: "noGlasses", "readingGlasses", "sunglasses", and
                              "swimmingGoggles".
                            "hair": {
                                "bald": 0.0,  # A number describing confidence level
                                  of whether the person is bald. Required.
                                "hairColor": [
                                    {
                                        "color": "str",  # Name of the hair
                                          color. Required. Known values are: "unknown", "white",
                                          "gray", "blond", "brown", "red", "black", and "other".
                                        "confidence": 0.0  # Confidence level
                                          of the color. Range between [0,1]. Required.
                                    }
                                ],
                                "invisible": bool  # A boolean value describing
                                  whether the hair is visible in the image. Required.
                            },
                            "headPose": {
                                "pitch": 0.0,  # Value of angles. Required.
                                "roll": 0.0,  # Value of angles. Required.
                                "yaw": 0.0  # Value of angles. Required.
                            },
                            "mask": {
                                "noseAndMouthCovered": bool,  # A boolean value
                                  indicating whether nose and mouth are covered. Required.
                                "type": "str"  # Mask type if any of the face.
                                  Required. Known values are: "faceMask", "noMask",
                                  "otherMaskOrOcclusion", and "uncertain".
                            },
                            "noise": {
                                "noiseLevel": "str",  # An enum value indicating
                                  level of noise. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of noise
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. [0, 0.3) is low noise
                                  level. [0.3, 0.7) is medium noise level. [0.7, 1] is high noise
                                  level. Required.
                            },
                            "occlusion": {
                                "eyeOccluded": bool,  # A boolean value indicating
                                  whether eyes are occluded. Required.
                                "foreheadOccluded": bool,  # A boolean value
                                  indicating whether forehead is occluded. Required.
                                "mouthOccluded": bool  # A boolean value indicating
                                  whether the mouth is occluded. Required.
                            },
                            "qualityForRecognition": "str",  # Optional. Properties
                              describing the overall image quality regarding whether the image being
                              used in the detection is of sufficient quality to attempt face
                              recognition on. Known values are: "low", "medium", and "high".
                            "smile": 0.0  # Optional. Smile intensity, a number between
                              [0,1].
                        },
                        "faceLandmarks": {
                            "eyeLeftBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            }
                        },
                        "faceRectangle": {
                            "height": 0,  # The height of the rectangle, in pixels.
                              Required.
                            "left": 0,  # The distance from the left edge if the image to
                              the left edge of the rectangle, in pixels. Required.
                            "top": 0,  # The distance from the top edge if the image to
                              the top edge of the rectangle, in pixels. Required.
                            "width": 0  # The width of the rectangle, in pixels.
                              Required.
                        },
                        "recognitionModel": "str"  # Optional. The 'recognitionModel'
                          associated with this faceId. This is only returned when
                          'returnRecognitionModel' is explicitly set as true.
                    }
                ]
        """

    @distributed_trace
    def detect_from_url(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        url: str = _Unset,
        return_face_id: Optional[bool] = None,
        return_face_landmarks: Optional[bool] = None,
        return_face_attributes: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.RecognitionModel]] = None,
        return_recognition_model: Optional[bool] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        face_id_time_to_live: Optional[int] = None,
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]:
        # pylint: disable=line-too-long
        """Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks,
        and attributes.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword return_face_id: Return faceIds of the detected faces or not. The default value is
         true. Default value is None.
        :paramtype return_face_id: bool
        :keyword return_face_landmarks: Return face landmarks of the detected faces or not. The default
         value is false. Default value is None.
        :paramtype return_face_landmarks: bool
        :keyword return_face_attributes: Analyze and return the one or more specified face attributes
         in the comma-separated string like 'returnFaceAttributes=headPose,glasses'. Supported face
         attributes include headPose, glasses, occlusion, accessories, blur, exposure, noise, mask, and
         qualityForRecognition. Face attribute analysis has additional computational and time cost.
         Default value is None.
        :paramtype return_face_attributes: str
        :keyword recognition_model: The 'recognitionModel' associated with the detected faceIds. Known
         values are: "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default
         value is None.
        :paramtype recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Known
         values are: "detection_01", "detection_02", and "detection_03". Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword face_id_time_to_live: The number of seconds for the face ID being cached. Supported
         range from 60 seconds up to 86400 seconds. The default value is 86400 (24 hours). Default value
         is None.
        :paramtype face_id_time_to_live: int
        :return: list of FaceDetectionResult
        :rtype: list[~azure.ai.face.models.FaceDetectionResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"  # URL of input image. Required.
                }

                # response body for status code(s): 200
                response == [
                    {
                        "faceId": "str",  # Unique faceId of the detected face, created by
                          detection API and it will expire 24 hours after the detection call. Required.
                        "faceAttributes": {
                            "accessories": [
                                {
                                    "confidence": 0.0,  # Confidence level of the
                                      accessory type. Range between [0,1]. Required.
                                    "type": "str"  # Type of the accessory.
                                      Required. Known values are: "headwear", "glasses", and "mask".
                                }
                            ],
                            "age": 0,  # Optional. Age in years.
                            "blur": {
                                "blurLevel": "str",  # An enum value indicating level
                                  of blurriness. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of
                                  blurriness ranging from 0 to 1. Required.
                            },
                            "exposure": {
                                "exposureLevel": "str",  # An enum value indicating
                                  level of exposure. Required. Known values are: "underExposure",
                                  "goodExposure", and "overExposure".
                                "value": 0.0  # A number indicating level of exposure
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. Required.
                            },
                            "facialHair": {
                                "beard": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "moustache": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "sideburns": 0.0  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                            },
                            "glasses": "str",  # Optional. Glasses type if any of the
                              face. Known values are: "noGlasses", "readingGlasses", "sunglasses", and
                              "swimmingGoggles".
                            "hair": {
                                "bald": 0.0,  # A number describing confidence level
                                  of whether the person is bald. Required.
                                "hairColor": [
                                    {
                                        "color": "str",  # Name of the hair
                                          color. Required. Known values are: "unknown", "white",
                                          "gray", "blond", "brown", "red", "black", and "other".
                                        "confidence": 0.0  # Confidence level
                                          of the color. Range between [0,1]. Required.
                                    }
                                ],
                                "invisible": bool  # A boolean value describing
                                  whether the hair is visible in the image. Required.
                            },
                            "headPose": {
                                "pitch": 0.0,  # Value of angles. Required.
                                "roll": 0.0,  # Value of angles. Required.
                                "yaw": 0.0  # Value of angles. Required.
                            },
                            "mask": {
                                "noseAndMouthCovered": bool,  # A boolean value
                                  indicating whether nose and mouth are covered. Required.
                                "type": "str"  # Mask type if any of the face.
                                  Required. Known values are: "faceMask", "noMask",
                                  "otherMaskOrOcclusion", and "uncertain".
                            },
                            "noise": {
                                "noiseLevel": "str",  # An enum value indicating
                                  level of noise. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of noise
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. [0, 0.3) is low noise
                                  level. [0.3, 0.7) is medium noise level. [0.7, 1] is high noise
                                  level. Required.
                            },
                            "occlusion": {
                                "eyeOccluded": bool,  # A boolean value indicating
                                  whether eyes are occluded. Required.
                                "foreheadOccluded": bool,  # A boolean value
                                  indicating whether forehead is occluded. Required.
                                "mouthOccluded": bool  # A boolean value indicating
                                  whether the mouth is occluded. Required.
                            },
                            "qualityForRecognition": "str",  # Optional. Properties
                              describing the overall image quality regarding whether the image being
                              used in the detection is of sufficient quality to attempt face
                              recognition on. Known values are: "low", "medium", and "high".
                            "smile": 0.0  # Optional. Smile intensity, a number between
                              [0,1].
                        },
                        "faceLandmarks": {
                            "eyeLeftBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            }
                        },
                        "faceRectangle": {
                            "height": 0,  # The height of the rectangle, in pixels.
                              Required.
                            "left": 0,  # The distance from the left edge if the image to
                              the left edge of the rectangle, in pixels. Required.
                            "top": 0,  # The distance from the top edge if the image to
                              the top edge of the rectangle, in pixels. Required.
                            "width": 0  # The width of the rectangle, in pixels.
                              Required.
                        },
                        "recognitionModel": "str"  # Optional. The 'recognitionModel'
                          associated with this faceId. This is only returned when
                          'returnRecognitionModel' is explicitly set as true.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[List[_models.FaceDetectionResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if url is _Unset:
                raise TypeError("missing required argument: url")
            body = {"url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_detect_from_url_request(
            return_face_id=return_face_id,
            return_face_landmarks=return_face_landmarks,
            return_face_attributes=return_face_attributes,
            recognition_model=recognition_model,
            return_recognition_model=return_recognition_model,
            detection_model=detection_model,
            face_id_time_to_live=face_id_time_to_live,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FaceDetectionResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def detect_from_stream(
        self,
        image_content: bytes,
        *,
        return_face_id: Optional[bool] = None,
        return_face_landmarks: Optional[bool] = None,
        return_face_attributes: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.RecognitionModel]] = None,
        return_recognition_model: Optional[bool] = None,
        detection_model: Optional[Union[str, _models.DetectionModel]] = None,
        face_id_time_to_live: Optional[int] = None,
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]:
        # pylint: disable=line-too-long
        """Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks,
        and attributes.

        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword return_face_id: Return faceIds of the detected faces or not. The default value is
         true. Default value is None.
        :paramtype return_face_id: bool
        :keyword return_face_landmarks: Return face landmarks of the detected faces or not. The default
         value is false. Default value is None.
        :paramtype return_face_landmarks: bool
        :keyword return_face_attributes: Analyze and return the one or more specified face attributes
         in the comma-separated string like 'returnFaceAttributes=headPose,glasses'. Supported face
         attributes include headPose, glasses, occlusion, accessories, blur, exposure, noise, mask, and
         qualityForRecognition. Face attribute analysis has additional computational and time cost.
         Default value is None.
        :paramtype return_face_attributes: str
        :keyword recognition_model: The 'recognitionModel' associated with the detected faceIds. Known
         values are: "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default
         value is None.
        :paramtype recognition_model: str or ~azure.ai.face.models.RecognitionModel
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Known
         values are: "detection_01", "detection_02", and "detection_03". Default value is None.
        :paramtype detection_model: str or ~azure.ai.face.models.DetectionModel
        :keyword face_id_time_to_live: The number of seconds for the face ID being cached. Supported
         range from 60 seconds up to 86400 seconds. The default value is 86400 (24 hours). Default value
         is None.
        :paramtype face_id_time_to_live: int
        :return: list of FaceDetectionResult
        :rtype: list[~azure.ai.face.models.FaceDetectionResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "faceId": "str",  # Unique faceId of the detected face, created by
                          detection API and it will expire 24 hours after the detection call. Required.
                        "faceAttributes": {
                            "accessories": [
                                {
                                    "confidence": 0.0,  # Confidence level of the
                                      accessory type. Range between [0,1]. Required.
                                    "type": "str"  # Type of the accessory.
                                      Required. Known values are: "headwear", "glasses", and "mask".
                                }
                            ],
                            "age": 0,  # Optional. Age in years.
                            "blur": {
                                "blurLevel": "str",  # An enum value indicating level
                                  of blurriness. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of
                                  blurriness ranging from 0 to 1. Required.
                            },
                            "exposure": {
                                "exposureLevel": "str",  # An enum value indicating
                                  level of exposure. Required. Known values are: "underExposure",
                                  "goodExposure", and "overExposure".
                                "value": 0.0  # A number indicating level of exposure
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. Required.
                            },
                            "facialHair": {
                                "beard": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "moustache": 0.0,  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                                "sideburns": 0.0  # A number ranging from 0 to 1
                                  indicating a level of confidence associated with a property.
                                  Required.
                            },
                            "glasses": "str",  # Optional. Glasses type if any of the
                              face. Known values are: "noGlasses", "readingGlasses", "sunglasses", and
                              "swimmingGoggles".
                            "hair": {
                                "bald": 0.0,  # A number describing confidence level
                                  of whether the person is bald. Required.
                                "hairColor": [
                                    {
                                        "color": "str",  # Name of the hair
                                          color. Required. Known values are: "unknown", "white",
                                          "gray", "blond", "brown", "red", "black", and "other".
                                        "confidence": 0.0  # Confidence level
                                          of the color. Range between [0,1]. Required.
                                    }
                                ],
                                "invisible": bool  # A boolean value describing
                                  whether the hair is visible in the image. Required.
                            },
                            "headPose": {
                                "pitch": 0.0,  # Value of angles. Required.
                                "roll": 0.0,  # Value of angles. Required.
                                "yaw": 0.0  # Value of angles. Required.
                            },
                            "mask": {
                                "noseAndMouthCovered": bool,  # A boolean value
                                  indicating whether nose and mouth are covered. Required.
                                "type": "str"  # Mask type if any of the face.
                                  Required. Known values are: "faceMask", "noMask",
                                  "otherMaskOrOcclusion", and "uncertain".
                            },
                            "noise": {
                                "noiseLevel": "str",  # An enum value indicating
                                  level of noise. Required. Known values are: "low", "medium", and
                                  "high".
                                "value": 0.0  # A number indicating level of noise
                                  level ranging from 0 to 1. [0, 0.25) is under exposure. [0.25, 0.75)
                                  is good exposure. [0.75, 1] is over exposure. [0, 0.3) is low noise
                                  level. [0.3, 0.7) is medium noise level. [0.7, 1] is high noise
                                  level. Required.
                            },
                            "occlusion": {
                                "eyeOccluded": bool,  # A boolean value indicating
                                  whether eyes are occluded. Required.
                                "foreheadOccluded": bool,  # A boolean value
                                  indicating whether forehead is occluded. Required.
                                "mouthOccluded": bool  # A boolean value indicating
                                  whether the mouth is occluded. Required.
                            },
                            "qualityForRecognition": "str",  # Optional. Properties
                              describing the overall image quality regarding whether the image being
                              used in the detection is of sufficient quality to attempt face
                              recognition on. Known values are: "low", "medium", and "high".
                            "smile": 0.0  # Optional. Smile intensity, a number between
                              [0,1].
                        },
                        "faceLandmarks": {
                            "eyeLeftBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeLeftTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyeRightTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowLeftOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightInner": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "eyebrowRightOuter": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "mouthRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseLeftAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarOutTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRightAlarTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseRootRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "noseTip": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilLeft": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "pupilRight": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "underLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipBottom": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            },
                            "upperLipTop": {
                                "x": 0.0,  # The horizontal component, in pixels.
                                  Required.
                                "y": 0.0  # The vertical component, in pixels.
                                  Required.
                            }
                        },
                        "faceRectangle": {
                            "height": 0,  # The height of the rectangle, in pixels.
                              Required.
                            "left": 0,  # The distance from the left edge if the image to
                              the left edge of the rectangle, in pixels. Required.
                            "top": 0,  # The distance from the top edge if the image to
                              the top edge of the rectangle, in pixels. Required.
                            "width": 0  # The width of the rectangle, in pixels.
                              Required.
                        },
                        "recognitionModel": "str"  # Optional. The 'recognitionModel'
                          associated with this faceId. This is only returned when
                          'returnRecognitionModel' is explicitly set as true.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[List[_models.FaceDetectionResult]] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_face_detect_from_stream_request(
            return_face_id=return_face_id,
            return_face_landmarks=return_face_landmarks,
            return_face_attributes=return_face_attributes,
            recognition_model=recognition_model,
            return_recognition_model=return_recognition_model,
            detection_model=detection_model,
            face_id_time_to_live=face_id_time_to_live,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FaceDetectionResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def find_similar(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "faceIds": [
                        "str"  # An array of candidate faceIds. All of them are created by
                          Face - Detect and the faceIds will expire 24 hours after the detection call.
                          The number of faceIds is limited to 1000. Required.
                    ],
                    "maxNumOfCandidatesReturned": 0,  # Optional. The number of top similar faces
                      returned. The valid range is [1, 1000].It defaults to 20.
                    "mode": "str"  # Optional. Similar face searching mode. It can be
                      'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. Known values are:
                      "matchPerson" and "matchFace".
                }

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """

    @overload
    def find_similar(
        self,
        *,
        face_id: str,
        face_ids: List[str],
        content_type: str = "application/json",
        max_num_of_candidates_returned: Optional[int] = None,
        mode: Optional[Union[str, _models.FindSimilarMatchMode]] = None,
        **kwargs: Any,
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword face_ids: An array of candidate faceIds. All of them are created by Face - Detect and
         the faceIds will expire 24 hours after the detection call. The number of faceIds is limited to
         1000. Required.
        :paramtype face_ids: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_num_of_candidates_returned: The number of top similar faces returned. The valid
         range is [1, 1000].It defaults to 20. Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword mode: Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults
         to 'matchPerson'. Known values are: "matchPerson" and "matchFace". Default value is None.
        :paramtype mode: str or ~azure.ai.face.models.FindSimilarMatchMode
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """

    @overload
    def find_similar(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """

    @distributed_trace
    def find_similar(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_id: str = _Unset,
        face_ids: List[str] = _Unset,
        max_num_of_candidates_returned: Optional[int] = None,
        mode: Optional[Union[str, _models.FindSimilarMatchMode]] = None,
        **kwargs: Any,
    ) -> List[_models.FindSimilarResult]:
        # pylint: disable=line-too-long
        """Given query face's faceId, to search the similar-looking faces from a faceId array, a face list
        or a large face list.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_id: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id: str
        :keyword face_ids: An array of candidate faceIds. All of them are created by Face - Detect and
         the faceIds will expire 24 hours after the detection call. The number of faceIds is limited to
         1000. Required.
        :paramtype face_ids: list[str]
        :keyword max_num_of_candidates_returned: The number of top similar faces returned. The valid
         range is [1, 1000].It defaults to 20. Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword mode: Similar face searching mode. It can be 'matchPerson' or 'matchFace'. It defaults
         to 'matchPerson'. Known values are: "matchPerson" and "matchFace". Default value is None.
        :paramtype mode: str or ~azure.ai.face.models.FindSimilarMatchMode
        :return: list of FindSimilarResult
        :rtype: list[~azure.ai.face.models.FindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "faceIds": [
                        "str"  # An array of candidate faceIds. All of them are created by
                          Face - Detect and the faceIds will expire 24 hours after the detection call.
                          The number of faceIds is limited to 1000. Required.
                    ],
                    "maxNumOfCandidatesReturned": 0,  # Optional. The number of top similar faces
                      returned. The valid range is [1, 1000].It defaults to 20.
                    "mode": "str"  # Optional. Similar face searching mode. It can be
                      'matchPerson' or 'matchFace'. It defaults to 'matchPerson'. Known values are:
                      "matchPerson" and "matchFace".
                }

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,  # Confidence value of the candidate. The higher
                          confidence, the more similar. Range between [0,1]. Required.
                        "faceId": "str",  # Optional. faceId of candidate face when find by
                          faceIds.
                        "persistedFaceId": "str"  # Optional. PersistedFaceId of candidate
                          face when find by faceListId.
                    }
                ]
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.FindSimilarResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_id is _Unset:
                raise TypeError("missing required argument: face_id")
            if face_ids is _Unset:
                raise TypeError("missing required argument: face_ids")
            body = {
                "faceid": face_id,
                "faceids": face_ids,
                "maxnumofcandidatesreturned": max_num_of_candidates_returned,
                "mode": mode,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_find_similar_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FindSimilarResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def verify(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """Verify whether two faces belong to a same person or whether one face belongs to a person.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId1": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "faceId2": "str"  # faceId of the face, comes from Face - Detect. Required.
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @overload
    def verify(
        self, *, face_id1: str, face_id2: str, content_type: str = "application/json", **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """Verify whether two faces belong to a same person or whether one face belongs to a person.

        :keyword face_id1: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id1: str
        :keyword face_id2: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id2: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @overload
    def verify(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """Verify whether two faces belong to a same person or whether one face belongs to a person.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """

    @distributed_trace
    def verify(
        self, body: Union[JSON, IO[bytes]] = _Unset, *, face_id1: str = _Unset, face_id2: str = _Unset, **kwargs: Any
    ) -> _models.VerifyResult:
        # pylint: disable=line-too-long
        """Verify whether two faces belong to a same person or whether one face belongs to a person.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_id1: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id1: str
        :keyword face_id2: faceId of the face, comes from Face - Detect. Required.
        :paramtype face_id2: str
        :return: VerifyResult. The VerifyResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.VerifyResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId1": "str",  # faceId of the face, comes from Face - Detect. Required.
                    "faceId2": "str"  # faceId of the face, comes from Face - Detect. Required.
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,  # Confidence score of whether the two faces belong to the
                      same person or whether the face belongs to the person. The range is [0, 1].
                      Required.
                    "isIdentical": bool  # True if the two faces belong to the same person or the
                      face belongs to the person, otherwise false. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.VerifyResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_id1 is _Unset:
                raise TypeError("missing required argument: face_id1")
            if face_id2 is _Unset:
                raise TypeError("missing required argument: face_id2")
            body = {"faceid1": face_id1, "faceid2": face_id2}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_verify_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.VerifyResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def group(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> _models.GroupResult:
        # pylint: disable=line-too-long
        """Divide candidate faces into groups based on face similarity.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GroupResult. The GroupResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.GroupResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"  # Array of candidate faceId created by Face - Detect. The
                          maximum is 1000 faces. Required.
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "groups": [
                        [
                            "str"  # A partition of the original faces based on face
                              similarity. Groups are ranked by number of faces. Required.
                        ]
                    ],
                    "messyGroup": [
                        "str"  # Face ids array of faces that cannot find any similar faces
                          from original faces. Required.
                    ]
                }
        """

    @overload
    def group(
        self, *, face_ids: List[str], content_type: str = "application/json", **kwargs: Any
    ) -> _models.GroupResult:
        # pylint: disable=line-too-long
        """Divide candidate faces into groups based on face similarity.

        :keyword face_ids: Array of candidate faceId created by Face - Detect. The maximum is 1000
         faces. Required.
        :paramtype face_ids: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GroupResult. The GroupResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.GroupResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "groups": [
                        [
                            "str"  # A partition of the original faces based on face
                              similarity. Groups are ranked by number of faces. Required.
                        ]
                    ],
                    "messyGroup": [
                        "str"  # Face ids array of faces that cannot find any similar faces
                          from original faces. Required.
                    ]
                }
        """

    @overload
    def group(self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any) -> _models.GroupResult:
        # pylint: disable=line-too-long
        """Divide candidate faces into groups based on face similarity.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GroupResult. The GroupResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.GroupResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "groups": [
                        [
                            "str"  # A partition of the original faces based on face
                              similarity. Groups are ranked by number of faces. Required.
                        ]
                    ],
                    "messyGroup": [
                        "str"  # Face ids array of faces that cannot find any similar faces
                          from original faces. Required.
                    ]
                }
        """

    @distributed_trace
    def group(
        self, body: Union[JSON, IO[bytes]] = _Unset, *, face_ids: List[str] = _Unset, **kwargs: Any
    ) -> _models.GroupResult:
        # pylint: disable=line-too-long
        """Divide candidate faces into groups based on face similarity.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_ids: Array of candidate faceId created by Face - Detect. The maximum is 1000
         faces. Required.
        :paramtype face_ids: list[str]
        :return: GroupResult. The GroupResult is compatible with MutableMapping
        :rtype: ~azure.ai.face.models.GroupResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"  # Array of candidate faceId created by Face - Detect. The
                          maximum is 1000 faces. Required.
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "groups": [
                        [
                            "str"  # A partition of the original faces based on face
                              similarity. Groups are ranked by number of faces. Required.
                        ]
                    ],
                    "messyGroup": [
                        "str"  # Face ids array of faces that cannot find any similar faces
                          from original faces. Required.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GroupResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_ids is _Unset:
                raise TypeError("missing required argument: face_ids")
            body = {"faceids": face_ids}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_group_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GroupResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
